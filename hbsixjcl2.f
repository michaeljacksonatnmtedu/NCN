C ADDITION OF CD CORRECTIONS TO LAMBDA-DOUBLING PARAMETERS   JMB 5-1-97
C Corrections of COMMON BLOCKS B,MOLPZ MW 09-10-96
C formal corrections of BINTER, and FORMAT statements in SPCALC,SPCFIT
C              MW 09-10-96
C ADDITION OF IWU (ABILITY TO READ IN UNCERTAINTIES INSTEAD OF WEIGHTS)
C FLAG OF RESIDUALS GREATER THAN 3 TIMES THE UNCERTAINTY IN SPCFIT
C  JMB  12-4-96
C Correction of call to KOINZI (NOW INCLUDES XL VALUE)  JMB 4-4-96
c Correction of phase factor in field dependent part of I-coupled intensity
c calculation, TRANS   JMB 14-2-96
C SOME SIMPLIFICATION OF THE q LAMBDA DOUBLING TERM  JMB 10-7-95
c Plotting of tuning diagram no longer done by OXPLOT kdh 11-5-95
C ZERO-FIELD BASIS SET INTRODUCED IN QNLOAD JMB 7-5-95
C ERROR IN S/ROUTINE TRANS CORRECTED JMB 26-4-95
C ERROR IN S/ROUTINE TRADEC CORRECTED JMB 1-5-95
C ELECTRIC QUADRUPOLE ELEMENTS ADDED (I-COUPLED ONLY)  JMB 11-4-95
C SIGN OF ALPHA(P) CORRECTINS CHANGED  JMB 11-4-95
C SIGN OF GAMMAD CHANGED, BETA,ELMAS UPDATED TV 28/10/92
C TV 22/10/92 -IGL- SECTION SKIPPED, NEEDS TO BE REPROGRAMMED
C THIS MEANS THAT ZEEDEC AND ZEEMAN ARE NOT COMPLETE AT THE MOMENT !
C 8-4-1990 IMPROVED BY JMB IN BOULDER
C    6-1992 IMPROVED BY MARTINA HAVENITH
 
C        MULTIPLETS CONFORMING TO THE HUND (B) BASIS
C        ELECTRON SPIN IS FREELY CHOOSABLE
C        NUCLEAR SPIN IS FREELY CHOOSABLE
C        ORBITAL ANGULAR MOMENTUM IS FREELY CHOOSABLE
C                             (SPIN-ORBIT NOT FINISHED !)
C        MAXIMUM NUMBER OF BASIS ELEMENTS IS 60
C
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*3 UNIT,DUMMY
      CHARACTER*5 TITEL
      CHARACTER*60 TTEXT
      DIMENSION P(80),E(15),RHO(7),ATOM(2,7),XIA(7)
C
      COMMON/CONS/P
      COMMON/MODE/IFLD,ISPEC,INTEN
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/EIG/E,FLXC
      COMMON/EINEIT/UNIT
      COMMON/TIT/TITEL,ttext
      COMMON/MODEP/ IMOD
      COMMON/MODEI/ IDECOP
      COMMON/ISOTO/ATOM,RHO,XIA,IBOC,NISO
      COMMON/ILAB/LABEL
C              ELECTRON MASS
C***********************************************************************
C              Electron mass in a.u.:
C FOLLWING LINE USES GREEN BOOK VALUES(SAME AS MJJ):
      ELMAS=9.1093897D-31/1.6605402D-27
C***********************************************************************
C      CALL ERRSET(208,999,-1,1,0)
C
C     OPEN(5,FILE=' ')
C     OPEN(6,FILE=' ')
 
      READ(1,901) TITEL
  901 FORMAT(A5)
      READ(1,*) NISO,IFLD,ISPEC,INTEN
      READ(1,*) IMOD,IBOC
      READ(1,*) IDECOP,LABEL
      IF(LABEL.EQ.0) WRITE(2,910)
  910 FORMAT(////,' LABEL = 0   EIGENSTATES IDENTIFIED BY J VALUES'/)
      IF(LABEL.EQ.1) WRITE(2,911)
  911 FORMAT(////,' LABEL = 1   EIGENSTATES IDENTIFIED BY ENERGY ORDER'/
     &            ' 1 = LOWEST, 2 = NEXT LOWEST,ETC')
      READ(1,915) XL
      READ(1,915) XS
      READ(1,915) XI
C     XI NOW READ IN WITH ATOMIC MASSES
  915 FORMAT(14X,F5.1)
      READ(1,918) UNIT
  918 FORMAT(A3)
      READ(1,*) P(1),P(2),P(41),P(42)
      READ(1,*) P(3),P(4)
      READ(1,*) P(5),P(6),P(57),P(45),P(46)
      READ(1,*) P(7),P(8),P(58)
      READ(1,*) P(9),P(10),P(59)
      READ(1,*) P(11),P(12)
      READ(1,*) P(13),P(14),P(60)
      READ(1,*) P(15),P(16)
      READ(1,*) P(75),P(76)
      READ(1,*) P(77),P(78)
      READ(1,*) P(79),P(80)
      READ(1,*) P(17),P(18)
      READ(1,*) P(19),P(20)
      READ(1,*) P(63),P(64)
      READ(1,*) P(65),P(66)
      READ(1,*) P(21),P(22)
      READ(1,*) P(23),P(24)
C NUCLEAR HYPERFINE TERMS
      READ(1,*) P(25),P(26)
      READ(1,*) P(27),P(28)
      READ(1,*) P(29),P(30)
      READ(1,*) P(31),P(32)
C ELECTRIC QUADRUPOLE TERMS
      READ(1,*) P(71),P(72)
      READ(1,*) P(73),P(74)
C ZEEMAN TERMS
      READ(1,*) P(33),P(34)
      READ(1,*) P(35),P(36)
      READ(1,*) P(37),P(38)
      READ(1,*) P(39),P(40)
      READ(1,*) P(67),P(68)
      READ(1,*) P(69),P(70)
      READ(1,*) P(61)
      CALL KOPF(1)
C
C   READ IN BASIS PARAMETERS
C
      READ(1,*) IDN
      WRITE(2,912) IDN
  912 FORMAT('0',' CALCULATION WITH BASIS SET. DELTA N=',I3)

C
C  SELECTION OF TYPE OF CALCULATION
C
      READ(1,*) FLXC
      IF(IFLD.EQ.0) GOTO 110
      WRITE(2,800) FLXC
  800 FORMAT('0',' ZEEMAN INTERPOLATION RANGE ',F10.4,' GAUSS')
  110 CONTINUE
C
  122 READ(1,803) DUMMY
      IF(DUMMY.NE.'ISO') GOTO 122
      RHO(1)=1.D0
C     IF(NISO.GT.1) THEN
        WRITE(2,801)
  801   FORMAT(/' THE PARAMETERS RELATE TO ISOTOPE NUMBER 1'/
     &          ' THE ATOMIC MASSES OF THE CHOOSEN ISOTOPE ARE'/
     &          ' NUMBER      ATOM1           ATOM2',
     &          '                 RHO          I')
        DO 121 INISO=1,NISO
         READ(1,*) A,B,XIIA
         ATOM(1,INISO)=ELMAS/A
         ATOM(2,INISO)=ELMAS/B
         XIA(INISO)=XIIA
         IF(INISO.EQ.1) THEN
           RHO1=A*B/(A+B)
         ELSE
           RHO(INISO)=RHO1*(A+B)/(A*B)
         ENDIF
         WRITE(2,802) INISO,A,B,RHO(INISO),XIA(INISO)
  121   CONTINUE
C     ENDIF
  802 FORMAT(3X,I2,F15.7,F15.7,5X,F15.7,5X,F5.1)
  803 FORMAT(A3)
      IF(ISPEC.EQ.0) GOTO 115
      IF(ISPEC.EQ.2) GOTO 116
      WRITE(2,923)
  923 FORMAT(//////10X,'SPECTRUM PREDICTION MODE'///)
      CALL SPCALC(1)
	GOTO 120
  115 CONTINUE
      WRITE(2,924)
  924 FORMAT(//////10X,'LSQ FIT OF EXPERIMENTAL DATA'///)
C     NCONS=19
      CALL SPCFIT
      GOTO 120
  116 CONTINUE
      WRITE(2,925)
  925 FORMAT(//////10X,'CALCULATION OF ZEEMANSPLITTING'///)
      CALL SPCPLT
  120 CONTINUE
      WRITE(2,914)
  914 FORMAT(//////' ALL`S WELL THAT ENDS WELL '///////)
      STOP
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     KOPF
C
C UNTERPROGRAMM KOPF SCHREIBT DIE UEBERSCHRIFT FUER DEN OUTPUT
C UND UEBERNIMMT ALLE ANDERREN KOMENTARE
C SUBPROGRAM KOPF WRITES THE TITLES FOR THE OUTPUT
C AND TAKES OVER ALL OTHER COMMENTS
C
      SUBROUTINE KOPF(IHOPS)
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*3 UNIT
      CHARACTER*4 UNITS
      CHARACTER*5 TITEL
      CHARACTER*60 TTEXT
      DIMENSION P(80)
C
      COMMON/CONS/P
      COMMON/MODE/IFLD,ISPEC,INTEN
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/EINEIT/UNIT
      COMMON/TIT/TITEL,ttext
      COMMON/MODEP/ IMOD
      COMMON/MODEI/ IDECOP
      COMMON/MODPLT/ IKOINZ,IOUT,IPLOT
C
      GOTO (1,2,3) IHOPS
C
    1 CONTINUE
      WRITE(2,300) TITEL
  300 FORMAT(' THE MOLECULE ?',5X,A5)
C     WRITE(2,301) XI
C 301 FORMAT(/' THE NUCLEAR SPIN ?',5X,'I=',F5.1)
      WRITE(2,306) XL
  306 FORMAT(/' THE ORBITAL ANGULAR MOMENTUM ?',5X,'LAMBDA=',F5.1)
      WRITE(2,302) XS
  302 FORMAT(/' THE ELECTRON SPIN ?',5X,'S=',F5.1)
      IF(UNIT.EQ.'GHz') WRITE(2,303)
      IF(UNIT.NE.'GHz') WRITE(2,304)
  303 FORMAT(/' GIGAHERTZ (GHz) CHOSEN AS ENERGY',
     &' UNITS')
  304 FORMAT(/' WAVENUMBERS (cm-1) CHOSEN AS ENERGY',
     &' UNITS')
      IF(IMOD.EQ.0) THEN
        WRITE(2,*) ' PARAMETERS GIVEN IN THE "0-VERSION"'
      ELSE
        WRITE(2,*) ' PARAMETERS GIVEN IN THE "E-VERSION"'
      ENDIF
      IF(IDECOP.EQ.0) THEN
        WRITE(2,*)  '  NUCLEAR SPIN IS DECOUPLED'
      ELSE
        WRITE(2,*)  '  NUCLEAR SPIN IS COUPLED'
      ENDIF
      WRITE(2,305)
  305 FORMAT(//' LIST OF MOLECULAR PARAMETERS')
      WRITE(2,960) P(1),P(2)
  960 FORMAT(/'  VIBRATIONAL CONSTANTS'/
     &' (1)  WE =',F20.10,7X,' (2) WEXE=',F20.10)
      WRITE(2,961) P(3),P(4)
  961 FORMAT(' '/'  VIBRATIONAL CONSTANTS'/
     &' (3) WEYE=',F20.10,7X,' (4) WEZE=',F20.10)
      WRITE(2,970) P(5),P(6),P(57)
  970 FORMAT(' '/'   ROTATIONAL CONSTANTS'/
     &' (5)  B0 =',F20.10,7X,' (6) ALPHB=',F20.10,' BETAB=',F20.10)
      WRITE(2,980) P(7),P(8),P(58)
  980 FORMAT(' '/'  CENTRIFUGAL DISTORTION CONSTANTS'/
     &' (7) D0 =',F20.10,7X,' (8) ALPHAD=',F20.10,' (58) BETAD=',F20.10)
      WRITE(2,981) P(9),P(10),P(59)
  981 FORMAT(' '/'  SPIN-ROTATION CONSTANTS'/
     &' (9)  GAMMA0 =',F20.10 ,7X,' (10) ALPHAG =',F20.10,
     &' P(59) BETA_G =',F20.10)
      WRITE(2,982) P(11),P(12)
  982 FORMAT(' '/'  SPIN-SPIN CONSTANTS'/
     &' (11) LAMDA0 =',F20.10,7X,' (12) ALPHAL =',F20.10)
      WRITE(2,984) P(13),P(14),P(60)
  984 FORMAT(' '/'  SPIN-ORBIT PARAMETERS'/
     &' (13) A0     =',F20.10,7X,' (14) ALPHA_A =',F20.10,
     &' (60) BETA_A =',F20.10)
C  984 FORMAT(' '/'  4TH ORDER SPIN-SPIN PARAMETERS'/
C     &' (13) THETA  =',F20.10,7X,' (14) ALPHATH =',F20.10)
C      WRITE(2,998) P(15),P(16)
C  998 FORMAT(' '/'  THIRD ORDER SPIN-ROTATION CONSTANTS'/
C     &' (15) GAMMAS =',F20.10,7X,' (16) ALPHAGS =',F20.10)
      WRITE(2,950) P(75),P(76)
  950 FORMAT(' '/'  ROTATION CORRECTION TO SPIN-ROTATION CONSTANTS'/
     &' (75) GAMMAD =',F20.10,7X,' (76) ALPHA_GD =',F20.10)
      WRITE(2,951) P(77),P(78)
  951 FORMAT(' '/'  ROTATION CORRECTION TO SPIN-SPIN CONSTANTS'/
     &' (77) LAMBDAD =',F20.10,7X,' (78) ALPHAL_D =',F20.10)
      WRITE(2,952) P(79),P(80)
  952 FORMAT(' '/'  THIRD CENTRIFUGAL CORRECTION    '/
     &' (79) H       =',F20.10,7X,' (80) ALPHA_H  =',F20.10)
      IF(XL.EQ.1.D0) THEN
      WRITE(2,985) P(15),P(16)
  985 FORMAT(' '/'  LAMDA-DOUBLING PARAMETERS'/
     &' (15)  o =',F20.10,7X,' (16)   ALPHA(o)=   ',F20.10)
      WRITE(2,986) P(17),P(18)
  986 FORMAT(' '/'  '/
     &'  (17)  p =',F20.10,7X,' (18)   ALPHA(p)=   ',F20.10)
      WRITE(2,987) P(19),P(20)
  987 FORMAT(' '/'  '/
     &'  (19)    q = ',F20.10,7X,' (20)   ALPHA(q)=   ',F20.10)
      WRITE(2,88) P(63),P(64)
   88 FORMAT(' '/'  '/
     &'  (63)   p_D= ',F20.10,7X,' (64)  ALPHA(p_D)=   ',F20.10)
      WRITE(2,89) P(65),P(66)
   89 FORMAT(' '/'  '/
     &'  (65)   q_D= ',F20.10,7X,' (66)  ALPHA(q_D)=   ',F20.10)
      ENDIF
      IF(XL.EQ.2.D0) THEN
      WRITE(2,997) P(21),P(22)
  997 FORMAT('0'/'  LAMDA-DOUBLING PARAMETER'/
     &'  (21)   QDEL =',F20.10,7X,' (22)   ALPHA(QDEL)=   ',F20.10)
      WRITE(2,999) P(23),P(24)
  999 FORMAT('0'/'  '/
     &'  (23)  P+4Q =',F20.10,7X,' (24)   ALPHA(P4Q)=   ',F20.10)
      ENDIF
C     IF(XI.NE.0.D0) THEN
      WRITE(2,988) P(25),P(26)
  988 FORMAT('0'/'  HYPERFINE PARAMETERS'/
     &'  (25)    HA =',F20.10,7X,' (26)   ALPHA(HA)=   ',F20.10)
      WRITE(2,989) P(27),P(28)
  989 FORMAT(' '/'  '/
     &'  (27)    BF =',F20.10,7X,' (28)   ALPHA(BF)=   ',F20.10)
      WRITE(2,990) P(29),P(30)
  990 FORMAT(' '/'  '/
     &'  (29)    C = ',F20.10,7X,' (30)   ALPHA(C)=   ',F20.10)
      WRITE(2,991) P(31),P(32)
  991 FORMAT(' '/'  '/
     &'  (31)   HD = ',F20.10,7X,' (32)   ALPHA(HD)=   ',F20.10)
      WRITE(2,995) P(71),P(72)
  995 FORMAT(' '/'  '/
     &'  (71) eQq0 = ',F20.10,7X,' (72) ALPHA(eQq0)=   ',F20.10)
      WRITE(2,996) P(73),P(74)
  996 FORMAT(' '/'  '/
     &'  (73) eQq2 = ',F20.10,7X,' (74) ALPHA(eQq2)=   ',F20.10)
C     ENDIF
      IF(IFLD.EQ.0) GOTO 130
      WRITE(2,983) P(33),P(34)
  983 FORMAT(' '/' '/'  G-FACTORS AND VIBRATIONAL DEPENDENCE'/
     &' (33) gS  =',F18.10,'  (34) alpha_gS  =',F18.10)
      WRITE(2,992) P(35),P(36)
  992 FORMAT(' (35) gL  =',F18.10,'  (36) alpha_gL  =',F18.10)
      WRITE(2,993) P(37),P(38)
  993 FORMAT(' (37) gr  =',F18.10,'  (38) alpha_gr  =',F18.10)
      WRITE(2,994) P(39),P(40)
  994 FORMAT(' (39) glS =',F18.10,'  (40) alpha_glS =',F18.10)
      WRITE(2,976) P(67),P(68)
  976 FORMAT(' (67) gl` =',F18.10,'  (68) alpha_gl` =',F18.10)
      WRITE(2,977) P(69),P(70)
  977 FORMAT(' (69) gre` =',F18.10,' (70) alpha_gre` =',F18.10) 
      WRITE(2,978) P(61)
  978 FORMAT(' (61) gI =',F18.10)
  130 CONTINUE
      GOTO 400
C
    2 CONTINUE
C
      IF(UNIT.EQ.'GHz') THEN
         UNITS=' GHz'
      ELSE
         UNITS='cm-1'
      ENDIF
C      WRITE(2,310)
C  310 FORMAT(' ENSPRECHEND UNSERER NOMENLATUR NACH W.B. WERDEN'/
C     &       '  C12O16 LASER LINE WITH   (NIX)'/
C     &       '  C13O16    "         "  *      '/
C     &       '  C12O18    "         "  #      GEKENNZEICHNET')
      IF(IFLD.EQ.0) GOTO 37
      WRITE(2,111) UNITS
  111 FORMAT(' '/51X,'TABULAR OUTPUT OF RESULTS'//1X,
     &'QUANTUM NUMBERS OF THE STATES',21X,'OBS FREQ',4X,'CALC FREQ',5X,
     &'DIFF(O-C)',4X,'OBS FIELD',2X,'CALC FIELD',2X,'DIFF(O-C)',2X,
     &'TR'//
     &1X,'SUBSCRIPT 1=LOWER 2=UPPER',25X,'(               ',A4,'
     &            )',4X,'(           GAUSS             )')
C    &            )',4X,'(           GAUSS             )',2X,'MHZ/G')
      GOTO 400
   37 CONTINUE
      WRITE(2,222) UNITS
  222 FORMAT(' '/' TABULAR OUTPUT OF THE RESULTS '//
     11X,' QUANTUM NUMBERS OF THE STATES ',16X,
     3' OBS FREQ ',5X,' CALC FREQ ',5X,' DIFF(O-C)'//
     41X,'SUBSCRIPT 1=LOWER 2=UPPER'//1X,' ALL USED UNITS ',A4)
      GOTO 400
    3 CONTINUE
      WRITE(2,401)
  401 FORMAT(/' IN THIS BRANCH OF THE PROGRAM (ISPEC=2) , AND',
     &' THE COINCIDENCES ARE LISTED AND/OR PLOTTED.')
      IF(IOUT.EQ.0) THEN
        WRITE(2,*) 'NO OUTPUT OF THE PLOT VECTORS (EvsB) : IOUT=0'
      ENDIF
      IF(IPLOT.EQ.0) THEN
        WRITE(2,*) 'NO PLOT : IPLOT=0'
      ENDIF
      IF(IKOINZ.NE.0) THEN
        WRITE(2,*) 'THE CALCULATED COINCIDENCES ARE PLACED IN ',
     &             'FILE "FOR011.DAT".'
      ELSE
        WRITE(2,*) 'NO COINCIDENCES CALCULATED : IKOINZ=0'
      ENDIF
      GOTO 400
  400 CONTINUE
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCVC
C
C    MATREP
C
C  DIESES UNTEROROGRAMM STELLT DIE ABLEITUNGSMATRIZEN AUF
C  ES WERDEN NUR DIE NULLFELD ANTEILE OHNE HYPERFEINSTRUKTUR
C  UND OHNE LAMBDA-DOUBLING BERECHNET
C
      SUBROUTINE MATREP
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION QMAT(9,1830),QN(3,60)
C
      COMMON/QMATS/QMAT
C QMAT CONTAINS THE ABLEITUNGSMATRIZEN
      COMMON/QNOS/QN
C QN CONTAINS THE BASIS
      COMMON/DIM/JDIM
C JDIM = DIMENSION OF THE  BASIS
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
C THE ACTUAL QUANTUM NUMBERS
C
      COMMON/MODEI/ IDECOP
      DATA IB,ID,IGAM,ILAM,IA,IGAMS,IGAMD,ILAMD,IH,ISUM
     &        /1,2,3,4,5,6,7,8,9,9/
      ZERO =0.0D0
C  CALLS THE SUBROUTINE TO CALCULATE THE BASIS
      IF(IDECOP.EQ.0) THEN
        CALL QNLDEC
      ELSE
        CALL QNLOAD
      ENDIF
 
C  CALCULATES SEVERAL SPIN-DEPENDENT QUANTITIES
       XS11=XS*(XS+1.)
       XSRT=DSQRT(XS11*(2.*XS+1))
       XS2RT=ZERO
       IF(XS.GT.0.6) XS2RT=DSQRT((2.*XS-1)*(2.*XS)*
     & (2.*XS+1)*(2.*XS+2)*(2.*XS+3))
       XS3RT=ZERO
       IF(XS.GT.1.1) XS3RT=DSQRT((2.*XS-2)*(2.*XS+4))*XS2RT
       XS4RT=ZERO
       IF(XS.GT.1.6) XS4RT=DSQRT((2.*XS-3)*(2.*XS+5))*XS3RT
C
       DO 100 I1=1,JDIM
       DO 100 I2=1,I1
         ISYM=I1*(I1-1)/2+I2
         DO 102 I3=1,ISUM
          QMAT(I3,ISYM)=ZERO
  102    CONTINUE
C SELECTION RULES ON MATRIX ELEMENTS
         DELTAN=DABS(QN(1,I1)-QN(1,I2))
         IF(DELTAN.GT.2.1) GOTO 103
         DELTAJ=DABS(QN(2,I1)-QN(2,I2))
         IF(DELTAJ.GT.1.D-9) GOTO 100
         DELTAF=DABS(QN(3,I1)-QN(3,I2))
         IF(DELTAF.GT.1.D-9) GOTO 100
C
         XNV1=QN(1,I1)
         XNV2=QN(1,I2)
         XJV=QN(2,I1)
         XHFSV=QN(3,I1)
         XJ11=XJV*(XJV+1.)
         XN12=DSQRT((2.*XNV2+1.)*(2.*XNV1+1.))
         XN11=XNV1*(XNV1+1.)
         XNRT=DSQRT(XN11*(2.*XNV1+1))
C CALCULATES THE MATRIX
C
C  ROTATIONAL TERM               N**2                 -IB-
          IF(DELTAN.LT.0.1) THEN
            QMAT(IB,ISYM)=XN11
C  CENTRIFUGAL DISTORTION       -N**4                 -ID-
            QMAT(ID,ISYM)=-XN11**2
C                                                     -IH-
            QMAT(IH,ISYM)=XN11**3
c            write(9,*) ih,isym,'Qmat = ',qmat(ih,isym)
CSPIN-ROTATION COUPLING        N.S                  -IGAM-
            QMAT(IGAM,ISYM)=0.5*(XJ11-XN11-XS11)
C  SIGN CHANGED ACCORDING TO CONVENTION TV28/10/92      -IGAMD-
            QMAT(IGAMD,ISYM)=QMAT(IGAM,ISYM)*XN11
          ENDIF
C  SPIN-SPIN COUPLING        2(SZ**2-S**2)/3          -ILAM-
          EXPO1=(-1)**NINT(XNV1+XS+XJV)
          EXPO2=(-1)**NINT(XNV2-XL)
          VAR=EXPO1*EXPO2/3.D0
          VAR=VAR*XN12*XS2RT
          VAR=VAR*THREEJ(XNV2,2.D0,XNV1,-XL,0.0D0,XL)
          VAR=VAR*SIXJ(XS,XNV2,XJV,XNV1,XS,2.0D0)
          QMAT(ILAM,ISYM)=VAR
C Sign of following matrix element for Lambda_D now correct(+).
C D.A. Gillett  13-May-1993:
          QMAT(ILAMD,ISYM)=QMAT(ILAM,ISYM)*
     &            0.5D0*(XNV1*(XNV1+1.)+XNV2*(XNV2+1.))
C  SPIN-ORBIT COUPLING         LZ.SZ                  -IA-
C NEW CODE TV 22/10/92
        IF(XL.LT.0.1D0) GO TO 99
         VAR=(-1)**NINT(XNV1+XS+XJV+XNV2-XL)
         VAR=VAR*XL*XSRT*XN12*SIXJ(XS,XNV2,XJV,XNV1,XS,1.0D0)
         VAR=VAR*THREEJ(XNV2,1.0D0,XNV1,-XL,0.0D0,XL)
         QMAT(IA,ISYM)=VAR
   99     CONTINUE
 
C ONLY SPECIAL INTERACTIONS TO FOLLOW
C
        IF(XS.LT.1.4) GOTO 101
C THIRD ORDER SPIN-ROTATION COUPLING   T3LLN.T3SSS  JMB  -IGAMS-
c         THIS SECTION WAS COMMENTED OUT 27/8/97 FOR 6SIGMAM FEH DFH/JMB
         EXPO=(-1)**NINT(XS+XJV-XL+1)
         VAR=DSQRT(70./6.D0)*0.25*EXPO
         VAR=VAR*XN12*XNRT*THREEJ(XNV2,2.D0,XNV1,-XL,0.D0,XL)
C TO USE THIS EXPRESSION YOU HAVE TO INTRODUCE THE VERY SLOW RACAH-SUBR.
         VAR=VAR*SIXJ(XS,XNV2,XJV,XNV1,XS,3.D0)
C THE NEXT SIXJ SYMBOL CAN BE REARRANGED TO GIVE RANK 1
         VAR=VAR*SIXJ(2.D0,1.D0,3.D0,XNV1,XNV2,XNV1)
         VAR=VAR*XS3RT
         QMAT(IGAMS,ISYM)=VAR
c         write(8,*) igams,isym, qmat(igams,isym)
 
  103  IF(DELTAN.GT.4.1) GOTO 101
C    4TH ORDER SPIN-SPIN COUPLING
C      IF(XS.LT.1.9) GOTO 101
C       EXPO1=(-1)**NINT(XNV1+XS+XJV)
C       EXPO2=(-1)**NINT(XNV2-XL)
C       VAR=EXPO1*EXPO2/24.0D0
C       VAR=VAR*XN12*XS4RT
C       VAR=VAR*THREEJ(XNV2,4.0D0,XNV1,-XL,ZERO,XL)
C       VAR=VAR*SIXJ(XS,XNV2,XJV,XNV1,XS,4.0D0)
c        WRITE(9,1000) I,IT,DLDP(IT)
c 1000 FORMAT('  TRANSITION',I3,'  PARAMETER',I3,'  DLDP=',F20.7)
C       QMAT(IA,ISYM)=VAR
C  ANY FURTHER INTERACTION WITH DELAN <=2 SHOULD BE INSERTED BEFORE
C           LINE 103
  101  CONTINUE
C
C         WRITE(2,*) 'XNV1=',XNV1,'XNV2=',XNV2,'J=',XJV
C         WRITE(2,*) ISYM, QMAT(IA,ISYM)
 
  100 CONTINUE
 
c      DO 300 I1=1,ISUM
c       WRITE(9,*) 'MATREP WW ',I1
c       DO 301 I2=1,JDIM
c        WRITE(9,302)(QMAT(I1,(I2*(I2-1)/2+I3)),I3=1,I2)
c  302   FORMAT(/' ',6(D17.10,3X))
c  301  CONTINUE
c  300 CONTINUE
      RETURN
      END
C
C---------------------------------------------------------------------
C
C     SPCALC CALCULATES THE TRANSITION FREQUENCY FOR A GIVEN TRANSITION
C     (WITH OR WITHOUT FIELD) AND PREDICTS ,IF WANTED, THE MAGNETIC
C     FIELD COINCIDENCE
C
 
C---------------------------------------------------------------------
C
      SUBROUTINE SPCALC(IREAD)
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL QIP,LIP,REPEAT,ITER
      CHARACTER*3 UNIT,DUMMY
      CHARACTER*4 UNITS
      CHARACTER*5 TITEL
      CHARACTER*60 TTEXT
c      character*1 cpol
      DIMENSION E(15),EUNTEN(15),FCAL(15),BX(15),P(80),DB(2)
      DIMENSION RHO(7),ATOM(2,7),XIA(7)
C
      COMMON/SIM/ISIM
      COMMON/CONS/P
      COMMON/MODE/IFLD,ISPEC,INTEN
      COMMON/ISOTO/ATOM,RHO,XIA,IBOC,NISO
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/EIG/E,FLXC
      COMMON/EINEIT/UNIT
      COMMON/FIELD/BX
      COMMON/TIT/TITEL,ttext
      COMMON/MODEP/ IMOD
      COMMON/MODEI/ IDECOP
      COMMON/CPCALC/INQUAD,ITERA,EPSB
      DATA BLANK /99.0D0/
      DATA ZERO,ONE,TWO / 0.0D0,1.0D0,2.0D0/
C
      
	ICOUNT=0
C CP+ MARKS THE START OF INPUT DATA WHICH MUST BE READ IN FIRST
C IF CALLING FROM SPCPLT,IT IS READ IN FROM IKOINZ.DAT :
      IF(ISPEC.EQ.2) GOTO 206
  251 READ(1,250) DUMMY
      IF(DUMMY.NE.'CP+') GOTO 251
  250 FORMAT(A3)
      IF(IFLD.EQ.0)GO TO 207
      READ(1,*) INQUAD
      IF(INQUAD.EQ.1) THEN 
           WRITE(2,17)
         ELSE
           WRITE(2,18)
      ENDIF
   17 FORMAT(/' QUADRATIC INTERPOLATION')
   18 FORMAT(/' LINEAR INTERPOLATION')
      READ(1,*) ITERA
      READ(1,*) EPSB
      WRITE(2,19) ITERA,EPSB
   19 FORMAT(' MAX NO OF ITERATIONS =',I3,' FIELD CONVERGENCE ',
     & 'CRITERION =',F6.2,'GAUSS')  
C THE CALCULATED TRANSITIONS MUST BE PRECEDED BY DAT
  206 READ(IREAD,250) DUMMY
      IF(DUMMY.NE.'DAT') GOTO 206
      CALL KOPF(2)
C LISTS THE QUANTUM NUMBERS,MAGNETIC FIELD AND LASER FREQUENCY
  101 READ(IREAD,*) ISO,XL2,VAU2,XN2,XJ2,XHFS2,XM2,IPAR2,FREQ
      IF(VAU2.LT.0)GO TO 30
C TERMINATE WITH A NEGATIVE INPUT
      READ(IREAD,*) XL1,VAU1,XN1,XJ1,XHFS1,XM1,IPAR1,FLUX
C INITIATE ITERATION COUNT
      ITC=0
      QIP=INQUAD.EQ.1
      LIP=.TRUE.
      ITER=.TRUE.
      GO TO 200
C READS THE QUANTUM NUMBERS ETC. FOR THE ZERO-FIELD CALCULATION
  207 READ(IREAD,250) DUMMY
      IF(DUMMY.NE.'DAT') GOTO 207
      QIP=.FALSE.
      LIP=.FALSE.
      CALL KOPF(2)
  201 CONTINUE
      READ(IREAD,*) ISO,XL2,VAU2,XN2,XJ2,XHFS2,IPAR2,FREQ
      IF(VAU2.LT.0) GO TO 30
C TERMINATE WITH A NEGATIVE INPUT
      READ(IREAD,*) XL1,VAU1,XN1,XJ1,XHFS1,IPAR1
      ICOUNT=ICOUNT+1
C     WRITE(*,*) ICOUNT
      FLUX=ZERO
C  ASSUMES I-COUPLED BASIS SET
      XM1=XHFS1
      IF(XHFS1.EQ.BLANK) XM1=XJ1
      XM2=XHFS2
      IF(XHFS2.EQ.BLANK) XM2=XJ2
  200 CONTINUE
C HERE THE REQUIRED MAGNETIC FIELDS ARE CALCULATED
C
      IF(IFLD.EQ.0) THEN
        NOFLD=1
        DB(1)=0.0
        DB(2)=0.0
      ELSE
        NOFLD=3
        DB(1)=10.
        BOBS=FLUX
        IF(QIP) THEN
          DB(2)=FLXC
        ELSE
          DB(2)=10.
        ENDIF
      ENDIF
      DO 203 I=1,NOFLD
      BX(I)=FLUX+(I-2)*DB(2)
  203 CONTINUE
  205 CONTINUE
C
C CALCULATE THE LOWER STATE
      XI=XIA(ISO)
      XL=XL1
      VAU=VAU1
      XN=XN1
      XJ=XJ1
      XHFS=XHFS1
      IF(XHFS.EQ.BLANK) XI=ZERO
      XM=XM1
      IPAR=IPAR1
      IF(XI.LT.0.1) THEN
        IF(IDECOP.EQ.0) THEN
          XHFS=ZERO
        ELSE
          XHFS=XJ
        ENDIF
      ENDIF
      CALL MATREP
      IF(IFLD.NE.0) THEN
        IF(IDECOP.EQ.0) THEN
          CALL ZEEDEC
        ELSE
          CALL ZEEMAN
        ENDIF
      ENDIF
      IF(XI.NE.ZERO) THEN
        IF(IDECOP.EQ.0) THEN
          CALL HYPDEC
        ELSE
          CALL HYPERF
        ENDIF
      ENDIF
      IF(XL.EQ.ONE.AND.IPAR.NE.0) CALL DOUBLE
      IF(XL.EQ.TWO.AND.IPAR.NE.0) CALL DOUBDE
      CALL EIGNV(IEV,NOFLD)
      DO 202 I=1,NOFLD
        EUNTEN(I)=E(I)
C FEHLSUCH:
c        WRITE(2,*) 'spcalc: EUNTEN(I)=',EUNTEN(I)
  202 CONTINUE
      IF(IDECOP.EQ.0) THEN
        XMF=XM+XHFS
      ELSE
        XMF=XM
      ENDIF
      IF(INTEN.EQ.1) CALL STOR(IEV,XMF,IPAR)
C CALCULATE THE UPPER STATE
      XI=XIA(ISO)
      VAU=VAU2
      XL=XL2
      XN=XN2
      XJ=XJ2
      XHFS=XHFS2
      IF(XHFS.EQ.BLANK) XI=ZERO
      XM=XM2
      IF(XI.LT.0.1) THEN
        IF(IDECOP.EQ.0) THEN
          XHFS=0.0
        ELSE
          XHFS=XJ
        ENDIF
      ENDIF
      IPAR=IPAR2
      CALL MATREP
      IF(IFLD.NE.0) THEN
        IF(IDECOP.EQ.0) THEN
          CALL ZEEDEC
        ELSE
          CALL ZEEMAN
        ENDIF
      ENDIF
      IF(XI.NE.0.0D0) THEN
        IF(IDECOP.EQ.0) THEN
          CALL HYPDEC
        ELSE
          CALL HYPERF
        ENDIF
      ENDIF
      IF(XL.EQ.1.0D0.AND.IPAR.NE.0) CALL DOUBLE
      IF(XL.EQ.2.0D0.AND.IPAR.NE.0) CALL DOUBDE
      CALL EIGNV(IEV,NOFLD)
      DO 204 I=1,NOFLD
      FCAL(I)=E(I)-EUNTEN(I)
C FEHLSUCH:
c      WRITE(2,*) 'spcalc: E(I)=',E(I)
  204 CONTINUE
C
      IF(INTEN.EQ.1) THEN
        IF(IDECOP.EQ.0) THEN
          CALL TRADEC(IEV,IFLD,W)
        ELSE
          CALL TRANS(IEV,IFLD,W)
        ENDIF
      ENDIF
C
C  OUTPUT OF RESULTS
      IF(IFLD.EQ.0) THEN
        FDIF=FREQ-FCAL(1)
        FDGHz=FDIF*29.9792458
C       FCMHZ=FCAL(1)*29979.2458
        FCM=FCAL(1)
C  OUTPUT OF RESULTS
c*********************************************************************
c(kdh) Intensity multiplied by 2 for transitions with N" odd for
c  ^3Sigma spin statistics:
c*********************************************************************
c       if(mod(nint(xn1),2).eq.1) w = w*2.0D0
      WRITE(2,131) VAU2,XN2,XJ2,XHFS2,IPAR2,ISO
  131 FORMAT(/'   V2=',F4.1,' N2=',F4.1,' J2=',F4.1,' F2=',F4.1,
     &         ' IPAR2=',I2,' ISOTOPE NUMBER',I2)
      WRITE(2,141) VAU1,XN1,XJ1,XHFS1,IPAR1,FREQ,FCM,FDIF
  141 FORMAT('   V1=',F4.1,' N1=',F4.1,' J1=',F4.1,' F1=',F4.1,
     &' IPAR1=',I2,7X,F10.4,3X,F10.4,4X,F9.5)
      IF(INTEN.EQ.1) WRITE(2,15) W
      GO TO 201
      ELSE 
      IF (ITC.EQ.0) FCALC=FCAL(2)  
      CALL INTPOL(QIP,LIP,REPEAT,ITER,FCAL,FREQ,BX,FLUX,DB,
     &              BOBS,BCAL,TR,ITC,EPSB,ITERA)
C        WRITE(2,*) FCAL(2),BCAL
        BOBS=BCAL
C  LOOP BACK FOR ANOTHER CYCLE IF REPEAT.EQ.TRUE
        IF(REPEAT) GOTO 205
        BDIF=FLUX-BCAL
        FDIF=FREQ-FCALC
C OUTPUT OF RESULTS
        WRITE(2,13) VAU2,XN2,XJ2,XHFS2,XM2,IPAR2,ISO
   13   FORMAT(/' V2=',F4.1,' N2=',F4.1,' J2=',F4.1,' HF2=',F4.1,' M2=',
     &  F5.1,' IPAR2=',I2,'  ISOTOPE NUMBER',I2)
        WRITE(2,14) VAU1,XN1,XJ1,XHFS1,XM1,IPAR1,FREQ,FCALC,FDIF,FLUX,
     &              BCAL,BDIF,TR
   14   FORMAT(' V1=',F4.1,' N1=',F4.1,' J1=',F4.1,' HF1=',F4.1,' M1=',
     &  F5.1,' IPAR1=',I2,2X,F11.5,1X,F11.5,2X,F9.5,2X,F10.2,2X,F9.3,2X,
     &  F10.4,1X,F6.3)
        IF(INTEN.EQ.1) WRITE(2,15) W
c*********************************************************************
c Data required for LMRSIM is output to for013 (sigma polarization)
c  and for014 (pi polarization)
c**********************************************************************
        if(isim.eq.1)then
          idmj=idnint(dabs(xm2-xm1))
          if(idmj.gt.0) then
              write(13,645) dnint(flux),dabs(tr),w
          else
              write(14,645) dnint(flux),dabs(tr),w
          endif
c Setting second-last flag to 1 means the line is interpreted
c   as a saturation dip, and no Doppler profile is included
c   for that line.  Setting second-last flag to 0 gives normal
c   Doppler profile.
  645 format(' ',F7.1,2X,F6.3,2X,D10.3,'  1.0  0  -1.0')
        endif
   15   FORMAT(16X,' E-DIPOLE INTENSITY ( NO OCCUPATION FACTOR INCL. ) '
     & ,D12.5)
C       WRITE(2,16) ISO,W, BCAL,TR,XM2-XM1
   16   FORMAT(6X,I2,2X,D12.5,2X,F12.5,2X,F6.3,2X,F5.1)                 ,
        GO TO 101
      ENDIF
   30 write(13,236)
      write(14,236)
  236 format('-1. -1. -1. -1 -1 -1.')
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE IDFY(IEV)
C
C   SUBROUTINE LOOKS FOR THE POSITION OF THE EIGENVALUE IN L
C   BELONGING TO THE BASIS STATE |N,J,F>
C
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 L(60)
c      INTEGER DTYP(1200)
      DIMENSION EIGVEC(60,60),QN(3,60)
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/QNOS/QN
      COMMON/DIM/JDIM
      COMMON/LTO/EIGVEC,L
      COMMON/ILAB/LABEL
c      COMMON/ITYP/DTYP
 
      IF(LABEL.EQ.1) GOTO 110
      IF(LABEL.EQ.2) GOTO 943 
C SEARCH FOR BASIS VECTOR
C     WRITE(2,340)
C 340 FORMAT(' pridfy wurde aufgerufen')
      K=0
   10 K=K+1
      IF(QN(1,K).NE.XN) GOTO 10
      IF(QN(2,K).NE.XJ) GOTO 10
      IF(QN(3,K).NE.XHFS) GOTO 10
C  THE QUANTUM NUMBERS XN,XJ,XHFS OCCUPY THE II-TH POSITION
C  IN THE BASIS VECTOR
      II=K
      IS=1
      IFOUND=0
  100 CONTINUE
      DMAX=DABS(EIGVEC(II,IS))
      IB=1
  102 IF(DMAX.LT.DABS(EIGVEC(IB,IS))) GOTO 101
C DMAX NOT THE LARGEST COEFFICIENT FOR THIS EIGENSTATE (IS)
      IF(IB.EQ.JDIM) GOTO 103
C DMAX IS THE LARGEST COEFFICIENT I.E. HAVE FOUND A SUITABLE EIGENSTATE
      IB=IB+1
C CARRIES ON OVER REMAINING BASIS STATES FOR EIGENSTATE IS
      GOTO 102
  101 CONTINUE
      IF(IS.EQ.JDIM) GOTO 104
      IS=IS+1
      GOTO 100
  103 CONTINUE
C IN THE IEV-TH EIGESTATE, THE II-TH BASIS STATE HAS THE LARGEST COEFFICIENT
      IEV=IS
      IFOUND=IFOUND+1
      IF(IFOUND.NE.1) GOTO 105
C CARRIES ON SEARCHING OVER REMAINING EIGENSTATES
      GOTO 101
  104 CONTINUE
      IF(IFOUND.NE.1) GOTO 105
 
 
      RETURN
 


C
C    E'STATE IDENTIFICATION USING F1,F2,F3,... LABLES FOR SPIN COMPONENTS
  110 CONTINUE
C    ICOUNT COUNTS THE SPIN COMPONENTS IN ORDER OF INCREASING ENERGY
      ICOUNT=0
C    LOOP OVER EIGENSTATES
      DO 111 K=1,JDIM
      DMAX=0.0D0
        DO 112 KK=1,JDIM
        IF(DMAX.GT.DABS(EIGVEC(KK,K))) GOTO 112
        DMAX=DABS(EIGVEC(KK,K))
        ISTATE=KK
  112   CONTINUE
      IF(QN(1,ISTATE).NE.XN) GOTO 111
      IF(QN(3,ISTATE).NE.XHFS) GOTO 111
      ICOUNT=ICOUNT+1
      IF(ICOUNT.EQ.NINT(XJ)) GOTO 113
  111 CONTINUE
C    THE DESIRED EIGENSTATE IS EIGENSTATE K
  113 IEV=K
      RETURN
  943 IEV=NINT(XJ)

C FEHLS:
        WRITE(2,903) JDIM
  903   FORMAT('  THE NUMBER OF BASIS STATES ',I5)
        WRITE(2,904) (QN(1,I),QN(2,I),QN(3,I),I=1,JDIM)
  904   FORMAT(5(' ','|',F5.1,';',F5.1,';',F5.1,'>'))
        WRITE(2,300) (L(I),I=1,JDIM)
      RETURN
 
  105 CONTINUE
      WRITE(2,350) IFOUND,VAU,XN,XJ,XHFS,XM
  350 FORMAT('0',5('*'),'SUBROUTINE IDFY GIVES',I2,
     &' EIGENVALUE(S) TO',
     15(F5.1,','),5('*'),'ERROR')
C       FALLS EIN AUSDRUCK DER EIGENWERTE UND EIGENVEKTOREN ERWUENSCHT I
        WRITE(2,303) JDIM
  303   FORMAT('  THE NUMBER OF BASIS STATES ',I5)
        WRITE(2,304) (QN(1,I),QN(2,I),QN(3,I),I=1,JDIM)
  304   FORMAT(5(' ','|',F5.1,';',F5.1,';',F5.1,'>'))
        WRITE(2,300) (L(I),I=1,JDIM)
        DO 302 I=1,JDIM
        WRITE(2,301) (EIGVEC(I1,I),I1=1,JDIM)
  302   CONTINUE
  300   FORMAT('0','L=',7(3X,F13.5))
  301   FORMAT('0','EIGVEC',7(3X,F13.5))
C   WARNING!  I NOT CALCULATED CORRECTLY
        WRITE(2,20000) I
20000   FORMAT(///'****ERROR IN DATA POINT :',I3)
      STOP
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C         EIGNV
C
C SETZT AUS DEN EINZELNEN ABLEITUNGSMATRIZEN UND DEN MOLEKUELPARAMETERN
C DIE HAMILTON MATRIX (IN VEKTORFORM) ZUSAMMEN UND DIAGONALISIERT DIESE
C
      SUBROUTINE EIGNV(IEV,NOFLD)
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 L(60)
c      INTEGER DTYP(1200)
      DIMENSION E(15),BX(15)
      DIMENSION QMAT(9,1830),ZMAT(7,1830),EQMAT(2,1830)
      DIMENSION HMAT(4,1830),DMAT(6,1830),DDMAT(3,1830)
      DIMENSION EIGVEC(60,60),H(1830),HSTOR(1830),WK(1950)
C
      COMMON/MODE/IFLD,ISPEC,INTEN
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/EIG/E,FLXC
      COMMON/QMATS/QMAT
      COMMON/DMATS/DMAT
      COMMON/DDMATS/DDMAT
      COMMON/HMATS/HMAT
      COMMON/EQMATS/EQMAT
      COMMON/ZMATS/ZMAT
      COMMON/DIM/JDIM
      COMMON/MOLPV/VIBE
      COMMON/MOLPQ/BV,DV,GAMV,XLAMV,AV,GAMSV,GAMDV,XLAMDV,HV
      COMMON/MOLPZ/GS,GL,GR,GLS,GLP,GRP,GI
      COMMON/MOLPH/HA,HBF,HC,HD
      COMMON/MOLPEQ/EQ0,EQ2
      COMMON/MOLPD/OV,PV,QV,ODV,PDV,QDV
      COMMON/MOLPDD/QDEL,P4Q
      COMMON/FIELD/BX
      COMMON/MODEP/ IMOD
      COMMON/MODEI/ IDECOP
      COMMON/LTO/EIGVEC,L
c      COMMON/ITYP/DTYP
C
      DATA IB,ID,IGAM,ILAM,IA,IGAMS,IGAMD,ILAMD,IH
     &                        /1,2,3,4,5,6,7,8,9/
      DATA IGS,IGL,IGR,IGLS,IGLP,IGRP,IGI/1,2,3,4,5,6,7/
      DATA IO,IP,IQ,IOD,IPD,IQD/1,2,3,4,5,6/
      DATA IQDEL,IP4Q/1,2/
      DATA IHA,IHBF,IHC,IHD/1,2,3,4/
      DATA IQ0,IQ2/1,2/
      DATA ZERO,HALF,ONE,TWO/0.0D0,0.5D0,1.0D0,2.0D0/
C
      IF(IMOD.EQ.0) THEN
        CALL MOLP0
      ELSE
        CALL MOLPE
      ENDIF
cjmb      WRITE (2,*) 'AV=',AV,'BV=',BV,'DV=',DV
cjmb      WRITE (2,*) 'GAMV=',GAMV,'PV=',PV,'QV=',QV
cjmb      WRITE (2,*) 'GS=',GS
C
C  CALCULATES THE HAMILTONIAN MATRIX             -H-
      DO 20 I1=1,JDIM
        L(I1)=ZERO
       DO 21 I2=1,I1
         ISYM=I1*(I1-1)/2+I2
         H(ISYM)=ZERO
C FINE STRUCTURE PART
c         write(*,*) gamsv,qmat(igams,isym)
         H(ISYM)=H(ISYM)+BV*QMAT(IB,ISYM)
         H(ISYM)=H(ISYM)+DV*QMAT(ID,ISYM)
         H(ISYM)=H(ISYM)+GAMV*QMAT(IGAM,ISYM)
         H(ISYM)=H(ISYM)+XLAMV*QMAT(ILAM,ISYM)
         H(ISYM)=H(ISYM)+AV*QMAT(IA,ISYM)
         H(ISYM)=H(ISYM)+GAMSV*QMAT(IGAMS,ISYM)
         H(ISYM)=H(ISYM)+GAMDV*QMAT(IGAMD,ISYM)
         H(ISYM)=H(ISYM)+XLAMDV*QMAT(ILAMD,ISYM)
         H(ISYM)=H(ISYM)+HV*QMAT(IH,ISYM)
C LAMDA DOUBLING PART FOR PI STATES
         IF(XL.EQ.ONE.AND.IPAR.NE.0) THEN
           H(ISYM)=H(ISYM)+OV*DMAT(IO,ISYM)
           H(ISYM)=H(ISYM)+PV*DMAT(IP,ISYM)
           H(ISYM)=H(ISYM)+QV*DMAT(IQ,ISYM)
C           H(ISYM)=H(ISYM)+ODV*DMAT(IOD,ISYM)
           H(ISYM)=H(ISYM)+PDV*DMAT(IPD,ISYM)
           H(ISYM)=H(ISYM)+QDV*DMAT(IQD,ISYM)
C FEHLS
c          WRITE(2,*) 'PLAM=',PLAM,'DMAT=',DMAT(IPLAM,ISYM)
         ENDIF
C LAMDA-DOUBLING PART IN DELTA STATES
         IF(XL.EQ.TWO.AND.IPAR.NE.0) THEN
           H(ISYM)=H(ISYM)+QDEL*DDMAT(IQDEL,ISYM)
           H(ISYM)=H(ISYM)+P4Q*DDMAT(IP4Q,ISYM)
         ENDIF
C MAGNETIC HYPERFINE PART
         IF(XI.NE.0.0D0) THEN
           H(ISYM)=H(ISYM)+HA*HMAT(IHA,ISYM)
           H(ISYM)=H(ISYM)+HBF*HMAT(IHBF,ISYM)
           H(ISYM)=H(ISYM)+HC*HMAT(IHC,ISYM)
           H(ISYM)=H(ISYM)+HD*HMAT(IHD,ISYM)                     
         ENDIF
C ELECTRIC QUADRUPOLE PART
         IF(XI.GT.0.6D0) THEN
           H(ISYM)=H(ISYM)+EQ0*EQMAT(IQ0,ISYM)
          IF(DABS(XL-ONE).LT.0.1D0) THEN
           H(ISYM)=H(ISYM)+EQ2*EQMAT(IQ2,ISYM)
          ENDIF
         ENDIF
         HSTOR(ISYM)=H(ISYM)
   21  CONTINUE
   20 CONTINUE
C
       IF(IDECOP.EQ.0) THEN
C
C FOR I-DECOUPLED BASIS SET, DIGAGONALISATION OF THE HAMILTONIAN MATRIX AT 2500 GAUSS : 
C SEARCH FOR THE CORRECT EIGENVALUE AND ITS POSITION IN THE EIGENVECTOR L
C
 
         DO 51 I=1,ISYM
          H(I)=HSTOR(I)
          H(I)=H(I)+GS*0.*ZMAT(IGS,I)
          H(I)=H(I)+GL*0.*ZMAT(IGL,I)
          H(I)=H(I)+GR*0.*ZMAT(IGR,I)
          H(I)=H(I)+GLS*0.*ZMAT(IGLS,I)
c         H(I)=H(I)+GS*2500.*ZMAT(IGS,I)
c         H(I)=H(I)+GL*2500.*ZMAT(IGL,I)
c         H(I)=H(I)+GR*2500.*ZMAT(IGR,I)
c         H(I)=H(I)+GLS*2500.*ZMAT(IGLS,I)
C        mjfind - removed the 2500 G field and started at 0 G field 
C        so that J starts as a good quantum number
   51    CONTINUE
C        CALL EIGRS(H,JDIM,2,L,EIGVEC,60,WK,IER)
         CALL EIGV(H)
         CALL IDFY(IEV)
C         WRITE(2,*) '500',IEV
C          WRITE(2,302) (L(I),I=1,JDIM)
C          DO 303 I2=1,JDIM
C           WRITE(2,302) (EIGVEC(I2,I1),I1=1,JDIM)
C  303     CONTINUE
C
         IF(IFLD.EQ.0) THEN
C          CALL EIGRS(HSTOR,JDIM,2,L,EIGVEC,60,WK,IER)
           CALL EIGV(HSTOR)
           E(1)=L(IEV)+VIBE
C FEHLS:
C          WRITE(2,*) 'E(1)=',E(1)
C          WRITE(2,*) 'VIBE=',VIBE
C          WRITE(2,*) 'L(IEV)=',L(IEV)
           RETURN
         ENDIF
C
       ELSE
C
C DIAGONALISATION OF THE ZERO-FIELD MATRIX - LOOK FOR THE CORRECT
C EIGENVALUE AND ITS POSITION IN THE EIGENVECTOR L
C
C       CALL EIGRS(H,JDIM,2,L,EIGVEC,60,WK,IER)
        CALL EIGV(H)
        CALL IDFY(IEV)
C        WRITE(2,*)L(IEV)
C
        IF(IFLD.EQ.0) THEN
          E(1)=L(IEV)+VIBE
          RETURN
        ENDIF
      ENDIF
       ISYM=JDIM*(JDIM+1)/2
       DO 40 JB=1,NOFLD
        B0=BX(JB)
        DO 50 I=1,ISYM
         H(I)=HSTOR(I)
         H(I)=H(I)+GS*B0*ZMAT(IGS,I)
         H(I)=H(I)+GL*B0*ZMAT(IGL,I)
         H(I)=H(I)+GR*B0*ZMAT(IGR,I)
         H(I)=H(I)+GLS*B0*ZMAT(IGLS,I)
        IF(DABS(XL-ONE).LT.0.1D0) THEN
         H(I)=H(I)+GLP*B0*ZMAT(IGLP,I)
         H(I)=H(I)+GRP*B0*ZMAT(IGRP,I)
        ENDIF
        IF(XI.GT.ZERO) THEN
         H(I)=H(I)+GI*B0*ZMAT(IGI,I)
        ENDIF 
   50   CONTINUE
C       CALL EIGRS(H,JDIM,2,L,EIGVEC,60,WK,IER)
        CALL EIGV(H)
C  CHOOSE EIEGENSTATE NUMBER AT OBSERVED FIELD
c       CALL IDFY(IEV)
c       mjfind - JMB suggested this be removed!CALL IDFY(IEV)
        E(JB)=L(IEV)+VIBE
C        IF(JB.EQ.2) THEN
C          WRITE(2,*) BX(JB),IEV
C mjfind - uncomment the above expression if B and IEV are to be printed.
C          WRITE(2,302) (L(I),I=1,JDIM)
C          DO 301 I2=1,JDIM
C           WRITE(2,302) (EIGVEC(I2,I1),I1=1,JDIM)
C  302      FORMAT(/' ',7(D15.8,3X))
C  301     CONTINUE
C        ENDIF
  40  CONTINUE
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     MOLPE
C
C    CALCULATES THE MOLECULAR PARAMETERS FOR EVERY STATE AND
C    THE VIBRATIONAL ENERGY
C
      SUBROUTINE MOLPE
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION P(80),RHO(7),ATOM(2,7),XIA(7)
C
      COMMON/CONS/P
      COMMON/MOLPV/VIBE
      COMMON/MOLPQ/BV,DV,GAMV,XLAMV,AV,GAMSV,GAMDV,XLAMDV,HV
      COMMON/MOLPZ/GS,GL,GR,GLS,GLP,GRP,GI
      COMMON/MOLPD/OV,PV,QV,ODV,PDV,QDV
      COMMON/MOLPDD/QDEL,P4Q
      COMMON/MOLPH/HA,HBF,HC,HD
      COMMON/ISOTO/ATOM,RHO,XIA,IBOC,NISO
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
C
      IF(IBOC.EQ.1) THEN
        BOCWE=1.+ATOM(1,ISO)*P(41)+ATOM(2,ISO)*P(42)
        BOCBE=1.+ATOM(1,ISO)*P(45)+ATOM(2,ISO)*P(46)
        BOCAE=1.+ATOM(1,ISO)*P(53)+ATOM(2,ISO)*P(54)
      ELSE
        BOCWE=1.0
        BOCBE=1.0
        BOCAE=1.0
      ENDIF
      VAU05=VAU+0.5
      WURHO=DSQRT(RHO(ISO))
      VIBE=P(1)*BOCWE*WURHO*VAU05-P(2)*(WURHO*VAU05)**2+
     &     P(3)*(WURHO*VAU05)**3+P(4)*(WURHO*VAU05)**4
      BV=(P(5)*BOCBE-P(6)*VAU05*WURHO)*RHO(ISO)
      DV=(P(7)-P(8)*VAU05*WURHO)*RHO(ISO)**2
      GAMV=(P(9)-P(10)*VAU05*WURHO)*RHO(ISO)
      XLAMV=P(11)-P(12)*VAU05*WURHO
      AV=P(13)*BOCAE-P(14)*VAU05*WURHO
      GAMSV=P(15)-P(16)*VAU05
      GAMDV=(P(71)-P(72)*VAU05*WURHO)*RHO(ISO)**2
      XLAMDV=(P(73)-P(74)*VAU05*WURHO)*RHO(ISO)
      HV=(P(75)-P(76)*VAU05*WURHO)*RHO(ISO)**3
      IF(XL.EQ.1.0D0.AND.IPAR.NE.0) THEN
        OP=(P(15)-P(16)*VAU05*WURHO)
        PLAM=(P(17)-P(18)*VAU05*WURHO)*RHO(ISO)
        Q=(P(19)-P(20)*VAU05*WURHO)*RHO(ISO)**2
        QD=(P(60)-P(61)*VAU05*WURHO)*RHO(ISO)**2
      ENDIF
      IF(XL.EQ.2.0D0.AND.IPAR.NE.0) THEN
        QDEL=(P(21)-P(22)*VAU05*WURHO)*RHO(ISO)**4
        P4Q=(P(23)-P(24)*VAU05*WURHO)*RHO(ISO)**3
      ENDIF
      IF(XI.NE.0.0D0) THEN
        HA=P(25)-P(26)*VAU05
        HBF=P(27)-P(28)*VAU05
        HC=P(29)-P(30)*VAU05
        HD=P(31)-P(32)*VAU05
      ENDIF
      GS=P(33)-P(34)*VAU05
      GL=P(35)-P(36)*VAU05
      GR=P(37)-P(38)*VAU05
      GLS=P(39)-P(40)*VAU05
      GLP=(67)+P(68)*VAU05
      GRP=P(69)+P(70)*VAU05
      GI=P(61)
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C   CALCULATES THE MOLECULAR PARAMETER VALUES IN "0" MODE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C CHANGED TO  PAR(V)=PAR(E)+ALPHA(P)*(V+0.5)+BETA(P)*(V+0.5)**2+...
C JMB 11-4-95
      SUBROUTINE MOLP0
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION P(80),RHO(7),ATOM(2,7),XIA(7)
C
      COMMON/CONS/P
      COMMON/MOLPV/VIBE
      COMMON/MOLPQ/BV,DV,GAMV,XLAMV,AV,GAMSV,GAMDV,XLAMDV,HV
      COMMON/MOLPZ/GS,GL,GR,GLS,GLP,GRP,GI
      COMMON/MOLPD/OV,PV,QV,ODV,PDV,QDV
      COMMON/MOLPDD/QDEL,P4Q
      COMMON/MOLPH/HA,HBF,HC,HD
      COMMON/MOLPEQ/EQ0,EQ2
      COMMON/ISOTO/ATOM,RHO,XIA,IBOC,NISO
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      DATA ZERO,HALF,ONE,TWO/0.0D0,0.5D0,1.0D0,2.0D0/
C
      IF(IBOC.EQ.1) THEN
        BOCWE=1.+ATOM(1,ISO)*P(41)+ATOM(2,ISO)*P(42)
        BOCBE=1.+ATOM(1,ISO)*P(45)+ATOM(2,ISO)*P(46)
        BOCAE=1.+ATOM(1,ISO)*P(53)+ATOM(2,ISO)*P(54)
        BOCWEXE=ONE
      ELSE
        BOCWE=ONE
        BOCBE=ONE
        BOCAE=ONE
        BOCWEXE=ONE
      ENDIF
      VAU05=VAU+HALF
      BE=(P(5)-P(6)*0.5-P(57)*0.25)*BOCBE
      DE=P(7)-P(8)*0.5-P(58)*0.25
      GAME=P(9)-P(10)*0.5-P(59)*0.25D0
      XLAME=P(11)-P(12)*0.5
      AE=(P(13)-P(14)*0.5-P(60)*0.25D0)*BOCAE
C      GAMSE=P(15)-P(16)*0.5
      GAMDE=P(75)-P(76)*0.5
      XLAMDE=P(77)-P(78)*0.5
      HE=P(79)-P(80)*0.5
      WURHO=DSQRT(RHO(ISO))
      WE=P(1)+(TWO*P(2))-(3.25D0*P(3))-(5.0D0*P(4))
c     VIBE=P(1)*WURHO*VAU05-P(2)*(WURHO*VAU05)**2+P(3)*(WURHO*VAU05)**3
c    &           +P(4)*(WURHO*VAU05)**4 changed TV 18/1/93 :
      VIBE=WE*WURHO*VAU05-P(2)*BOCWEXE*(WURHO*VAU05)**2
     &      +P(3)*(WURHO*VAU05)**3+P(4)*(WURHO*VAU05)**4
      BV=BE*RHO(ISO)+P(6)*VAU05*WURHO**3+P(57)*VAU05**2*RHO(ISO)**2
      DV=DE*RHO(ISO)**2+P(8)*VAU05*WURHO**5+P(58)*VAU05**2*RHO(ISO)**3
      GAMV=(GAME+P(10)*VAU05*WURHO)*RHO(ISO)+P(59)*(VAU05*RHO(ISO))**2
      XLAMV=XLAME+P(12)*VAU05*WURHO
      AV=AE+P(14)*VAU05*WURHO+P(60)*(VAU05*WURHO)**2
C      GAMSV=(GAMSE+P(16)*VAU05*WURHO)
      GAMDV=(GAMDE+P(76)*VAU05*WURHO)*RHO(ISO)**2
      XLAMDV=(XLAMDE+P(78)*VAU05*WURHO)*RHO(ISO)
      HV=(HE+P(80)*VAU05*WURHO)*RHO(ISO)**3
      IF(XL.EQ.ONE.AND.IPAR.NE.0) THEN
        OE=P(15)-P(16)*HALF
        PE=P(17)-P(18)*HALF
        QE=P(19)-P(20)*HALF
C        ODE=P(61)-P(62)*HALF
        PDE=P(63)-P(64)*HALF
        QDE=P(65)-P(66)*HALF
        OV=OE+P(16)*VAU05*WURHO
        PV=(PE+P(18)*VAU05*WURHO)*RHO(ISO)
        QV=(QE+P(20)*VAU05 *WURHO)*RHO(ISO)**2
C        ODV=(ODE+P(62)*VAU05*WURHO)*RHO(ISO)
        PDV=(PDE+P(64)*VAU05*WURHO)*RHO(ISO)**2
        QDV=(QDE+P(66)*VAU05*WURHO)*RHO(ISO)**3
      ENDIF
      IF(XL.EQ.2.0D0.AND.IPAR.NE.0) THEN
        QDELE=P(21)-P(22)*HALF
        P4QE=P(23)-P(24)*HALF
        QDEL=(QDELE+P(22)*VAU05*WURHO)*RHO(ISO)**4
        P4Q=(P4QE+P(24)*VAU05*WURHO)*RHO(ISO)**3
      ENDIF
      IF(XI.NE.0.0D0) THEN
        HAE=P(25)-P(26)*HALF
        HBFE=P(27)-P(28)*HALF
        HCE=P(29)-P(30)*HALF
        HDE=P(31)-P(32)*HALF
        HA=HAE+P(26)*VAU05
        HBF=HBFE+P(28)*VAU05
        HC=HCE+P(30)*VAU05
        HD=HDE+P(32)*VAU05
      ENDIF
       IF(XI.GT.0.6D0) THEN
	EQ0E=P(71)-P(72)*HALF
	EQ2E=P(73)-P(74)*HALF
	EQ0=EQ0E+P(72)*VAU05
	EQ2=EQ2E+P(74)*VAU05
       ENDIF
      GSE=P(33)-P(34)*HALF
      GLE=P(35)-P(36)*HALF
      GRE=P(37)-P(38)*HALF
      GLSE=P(39)-P(40)*HALF
      GLPE=P(67)-P(68)*HALF
      GRPE=P(69)-P(70)*HALF
      GS=GSE+P(34)*VAU05
      GL=GLE+P(36)*VAU05
      GR=GRE+P(38)*VAU05
      GLS=GLSE+P(40)*VAU05
      GLP=GLPE+P(68)*VAU05
      GRP=GRPE+P(70)*VAU05
      GI=P(61)
c fehls:
c      WRITE(2,*) 'molp0 vibe=',vibe
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C      QNLOAD
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE QNLOAD
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION QN(3,60)
C
      COMMON/QNOS/QN
      COMMON/DIM/JDIM
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/MODE/IFLD,ISPEC,INTEN
C
C     READ(1,*) XI,XS,XN,XM,IDN
C     To ensure that IDN is even for Sigma States
      IF(XL.LT.0.1) IDN=2*(IDN/2)
C     mjfind - above two lines were added 
      MULTIN=2*IDN+1
      XNMIN=XN-IDN
      NSTEP=2
      IF(XL.GT.0.0) NSTEP=1
C     WRITE(2,*) 'XN=',XN,'IDN=',IDN
      IF(IFLD.EQ.0) GOTO 29
      AMF=DABS(XM)
      JDIM=0
      DO 20 IN=1,MULTIN,NSTEP
       XNV=XNMIN+IN-1
C      WRITE(2,*) 'XNV=',XNV
       IF(XNV.LT.XL) GOTO 20
       XJMIN=DABS(XNV-XS)
       MULTIS=NINT(2.*DMIN1(XNV,XS)+1)
C      WRITE(2,*) 'MULTIS=',MULTIS
       DO 21 IJ=1,MULTIS
C      WRITE(2,*) 'XJV=',XJV
       XJV=XJMIN-1+IJ
        XFMIN=DABS(XJV-XI)
        MULTII=NINT(2.*DMIN1(XJV,XI)+1.)
        DO 22 II=1,MULTII
         XHFSV=XFMIN-1+II
        IF(XHFSV.LT.AMF) GOTO 22
          JDIM=JDIM+1
          QN(1,JDIM)=XNV
          QN(2,JDIM)=XJV
          QN(3,JDIM)=XHFSV
   22   CONTINUE
   21  CONTINUE
   20 CONTINUE
      IF (JDIM.GT.60) WRITE(2,302)JDIM
 302  FORMAT(' WARNING JDIM GREATER THAN 60, EQUALS ',I3)
      RETURN
C   BASIS SET FOR ZERO-FIELD CALCULATION, DIAGONAL IN F (XHFS)
   29 JDIM=0
      DO 30 IN=1,MULTIN,NSTEP
      XNV=XNMIN+IN-1
      IF(XNV.LT.XL) GOTO 30
      IF((XNV+XS+XI+0.1).LT.XHFS) GOTO 30
      IF((DABS(XNV-XI)-XS).GT.XHFS) GOTO 30
      XJMIN=DABS(XNV-XS)
      MULTIS=NINT(2.*DMIN1(XNV,XS)+1)
C       LOOP OVER POSSIBLE J VALUES
        DO 31 IJ=1,MULTIS
        XJV=XJMIN+IJ-1
        IF((XJV+XI+0.1).LT.XHFS) GOTO 31
        IF(DABS(XJV-XI).GT.XHFS) GOTO 31
        JDIM=JDIM+1
        QN(1,JDIM)=XNV
        QN(2,JDIM)=XJV
        QN(3,JDIM)=XHFS
   31   CONTINUE
   30   CONTINUE
        IF (JDIM.GT.60) WRITE(2,302) JDIM
c        WRITE(2,300) JDIM
c 300    FORMAT('  DIE ZAHL DER BASIS VEKTOREN ',I5)
c        WRITE(2,301) (QN(1,I),QN(2,I),QN(3,I),I=1,JDIM)
c 301    FORMAT(5(' ','|',F5.1,';',F5.1,';',F5.1,'>'))
	RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C      QNLDEC
C
      SUBROUTINE QNLDEC
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION QN(3,60)
C
      COMMON/QNOS/QN
      COMMON/DIM/JDIM
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
C
C     READ(1,*) XI,XS,XN,XM,IDN
      MULTII=NINT(2.*XI+1.)
C     To ensure that IDN is even for Sigma States
      IF(XL.LT.0.1) IDN=2*(IDN/2)
C     mjfind - above two lines were added 
      MULTIN=2*IDN+1
      XMF=XM+XHFS
      XNMIN=XN-IDN
      NSTEP=2
      IF(XL.GT.0.0) NSTEP=1
C     mjfind - above two lines were added 
      JDIM=0
      DO 20 IN=1,MULTIN,NSTEP
C     mjfind - above line was modified by adding ,NSTEP - original is below 
C     DO 20 IN=1,MULTIN
       XNV=XNMIN+IN-1
       IF(XNV.LT.XL) GOTO 20
       XJMIN=DABS(XNV-XS)
       MULTIS=NINT(2.*DMIN1(XNV,XS)+1)
       DO 21 IJ=1,MULTIS
       XJV=XJMIN+IJ-1
        DO 22 II=1,MULTII
         XMIV=-XI-1+II
         XMJV=XMF-XMIV
        IF(DABS(XMJV).GT.XJV) GOTO 22
          JDIM=JDIM+1
          QN(1,JDIM)=XNV
          QN(2,JDIM)=XJV
          QN(3,JDIM)=XMIV
   22   CONTINUE
   21  CONTINUE
   20 CONTINUE
C
C      WRITE(2,300) JDIM
C  300 FORMAT('  DIE ZAHL DER BASIS VEKTOREN ',I5)
C      WRITE(2,301) (QN(1,I),QN(2,I),QN(3,I),I=1,JDIM)
C  301 FORMAT(5(' ','|',F5.1,';',F5.1,';',F5.1,'>'))
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C   EIGV
C
C
C   UEBERTRAEGT DIE ALS VEKTOR ABGESPEICHERTE MATRIX H(1830) IN
C   DIE MATRIX SH(60,60) ZUR DIAGONALISIERUNG
C
      SUBROUTINE EIGV(H)
      IMPLICIT REAL *8 (A-H,O-Z)
      DIMENSION SH(60,60)
      DIMENSION H(1830),EIGVEC(60,60)
      REAL*8 L(60),WK(60)
      COMMON/DIM/JDIM
      COMMON/LTO/EIGVEC,L
      ITEST=0
      DO 100 I1=1,60
      DO 101 I2=1,I1
      ISYM=I1*(I1-1)/2+I2
      SH(I1,I2)=H(ISYM)
      SH(I2,I1)=SH(I1,I2)
  101 CONTINUE
C FEHLSUCH:
c     IF((I1.LE.10).AND.(I2.LE.10)) THEN
c      WRITE(2,*) (SH(I1,I2),I2=1,I1)
c     ENDIF
  100 CONTINUE
c     WRITE(2,*) '   '
      IFAIL=0
C     CALL F02ABF(SH,60,JDIM,L,EIGVEC,60,WK,IFAIL)
C        CALL DEVCSF(JDIM,SH,60,L,EIGVEC,60)
C************************************************************
C
C
C Routine to calculate the Eigenvalues and Eigenvectors of SH:
C
CNAG      CALL F02ABF(SH,60,JDIM,L,EIGVEC,60,WK,IFAIL)
C
C Following replaces NAG; coded to use the same algorithms as
C F02ABF, namely Householder reduction followed by the QL
C algorithm. Adapted from Numerical Recipes p355,356,362,363.
C D.A.G. 8-JUNE-1992:
       CALL MATREV(SH,L,EIGVEC,JDIM,60)
C
C
C**************************************************************
       IF(ITEST.EQ.0) GOTO 303
C       FALLS EIN AUSDRUCK DER EIGENWERTE UND EIGENVEKTOREN ERWUENSCHT I
        WRITE(2,300) (L(I),I=1,JDIM)
        DO 302 I=1,JDIM
        WRITE(2,301) (EIGVEC(I1,I),I1=1,JDIM)
  302   CONTINUE
  300   FORMAT('0','L=',7(3X,F13.5))
  301   FORMAT('0','EIGVEC',7(3X,F13.5))
  303 CONTINUE
      RETURN
      END
 
C-----------------------------------------------------------------------
C234567
      SUBROUTINE MATREV(A,D,EIGVEC,N,NP)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z), INTEGER (I-N)
      REAL*8 EIGVEC(NP,NP)
      DIMENSION A(NP,NP),D(NP),E(150),RO(150),INDX(150)
C
C The matrix whose eigenvalues and eigenvectors are to be found is A.
C A has total dimension (NP,NP); the subset (N,N) is used in this case.
C D is the matrix of eigenvalues, dimensioned D(NP), where D(N) is used.
C EIGVEC is the matrix of eigenvectors. It has dimension (NP,NP) of
C which (N,N) is used.
C
C Call Householder Reduction to reduce the matrix to tri-diagonal form.
C A=matrix, D=diagonals of tri-diagonal, E= first sub-diagonals;
C E(1)=0.0D0:
      CALL HRD(A,N,NP,D,E)
C Call the QL algorithm to determine the Eigenvalues and Eigenvectors
C of the matrix A:
      CALL QL(D,E,N,NP,A)
C
      CALL ESORT(D,RO,EIGVEC,A,INDX,N,NP)
      RETURN
      END
 
 
 
      SUBROUTINE HRD(A,N,NP,D,E)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z), INTEGER (I-N)
      DIMENSION A(NP,NP),D(NP),E(NP)
C
C This routine performs the Householder reduction:
      IF(N.GT.1)THEN
       DO 18 I=N,2,-1
        L=I-1
        H=0.0D0
        SCALE=0.0D0
         IF(L.GT.1)THEN
          DO 11 K=1,L,1
           SCALE=SCALE+DABS(A(I,K))
 11       CONTINUE
          IF(SCALE.EQ.0.0D0)THEN
           E(I)=A(I,L)
          ELSE
           DO 12 K=1,L,1
            A(I,K)=A(I,K)/SCALE
            H=H+A(I,K)*A(I,K)
 12        CONTINUE
          F=A(I,L)
          G=-DSIGN(DSQRT(H),F)
          E(I)=SCALE*G
          H=H-F*G
          A(I,L)=F-G
          F=0.0D0
          DO 15 J=1,L,1
           A(J,I)=A(I,J)/H
          G=0.0D0
           DO 13 K=1,J,1
            G=G+A(J,K)*A(I,K)
 13        CONTINUE
           IF(L.GT.J)THEN
           DO 14 K=J+1,L,1
            G=G+A(K,J)*A(I,K)
 14        CONTINUE
          ENDIF
          E(J)=G/H
          F=F+E(J)*A(I,J)
 15       CONTINUE
          HH=F/(H+H)
          DO 17 J=1,L,1
           F=A(I,J)
           G=E(J)-HH*F
           E(J)=G
           DO 16 K=1,J,1
            A(J,K)=A(J,K)-F*E(K)-G*A(I,K)
  16       CONTINUE
  17      CONTINUE
         ENDIF
        ELSE
         E(I)=A(I,L)
        ENDIF
        D(I)=H
 18    CONTINUE
      ENDIF
      D(1)=0.0D0
      E(1)=0.0D0
      DO 23 I=1,N,1
       L=I-1
       IF(D(I).NE.0.0D0)THEN
       DO 21 J=1,L,1
        G=0.0D0
        DO 19 K=1,L,1
         G=G+A(I,K)*A(K,J)
 19     CONTINUE
        DO 20 K=1,L,1
         A(K,J)=A(K,J)-G*A(K,I)
 20     CONTINUE
 21    CONTINUE
      ENDIF
      D(I)=A(I,I)
      A(I,I)=1.0D0
      IF(L.GE.1)THEN
       DO 22 J=1,L,1
        A(I,J)=0.0D0
        A(J,I)=0.0D0
 22    CONTINUE
      ENDIF
 23       CONTINUE
      RETURN
      END
 
      SUBROUTINE QL(D,E,N,NP,Z)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z), INTEGER (I-N)
      DIMENSION D(NP),E(NP),Z(NP,NP)
C
C This routine finds the eigenvalues by the QL reduction and then
C the eigenvectors of the transformation matrix Z from the
C Householder reduction.
      IF(N.GT.1)THEN
       DO 11 I=2,N,1
        E(I-1)=E(I)
 11    CONTINUE
       E(N)=0.0D0
       DO 15 L=1,N,1
        ITER=0
 1      DO 12 M=L,N-1,1
         DD=DABS(D(M))+DABS(D(M+1))
         IF(DABS(E(M))+DD.EQ.DD) GOTO 2
 12     CONTINUE
        M=N
 2      IF(M.NE.L)THEN
         IF(ITER.EQ.30)THEN
C Too many iterations for numerical stability:
          IFAIL=1
          WRITE(2,*) '  ***Failure in MATREV, too many iterations***'
          STOP
         ENDIF
         ITER=ITER+1
         G=(D(L+1)-D(L))/(2.0D0*E(L))
         R=DSQRT(G*G+1.0D0)
         G=D(M)-D(L)+E(L)/(G+DSIGN(R,G))
         S=1.0D0
         C=1.0D0
         P=0.0D0
         DO 14 I=M-1,L,-1
          F=S*E(I)
          B=C*E(I)
          IF(DABS(F).GE.DABS(G))THEN
           C=G/F
           R=DSQRT(C*C+1.0D0)
           E(I+1)=F*R
           S=1.0D0/R
           C=C*S
          ELSE
           S=F/G
           R=DSQRT(S*S+1.0D0)
           E(I+1)=G*R
           C=1.0D0/R
           S=S*C
          ENDIF
          G=D(I+1)-P
          R=(D(I)-G)*S+2.0D0*C*B
          P=S*R
          D(I+1)=G+P
          G=C*R-B
          DO 13 K=1,N,1
           F=Z(K,I+1)
           Z(K,I+1)=S*Z(K,I)+C*F
           Z(K,I)=C*Z(K,I)-S*F
 13       CONTINUE
 14      CONTINUE
         D(L)=D(L)-P
         E(L)=G
         E(M)=0.0D0
         GOTO 1
        ENDIF
 15     CONTINUE
       ENDIF
       RETURN
       END
 
       SUBROUTINE ESORT(R,RO,EIGVEC,V,INDX,N,NP)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z), INTEGER (I-N)
      DIMENSION R(NP),V(NP,NP),EIGVEC(NP,NP),RO(NP),INDX(NP)
C
C The routine returns the Eigenvalues in sorted form using a
C Shell-sort routine to get the Eigenvalues in order of increasing
C Eigenvalue, which is the same format as the NAG routine F02ABF.
C The Eigenvector coefficients are then moved to lie in a column
C below the correct Eigenvalue.
C
      DO 3004 I=1,N,1
      RO(I)=R(I)
3004  CONTINUE
C Now perform a Shell sort to get the Eigenvalues in increasing order:
      DO 3005 I=1,N-1,1
       DO 3007 J=I,N,1
        IF(R(I).GT.R(J))THEN
        RT=R(I)
        R(I)=R(J)
        R(J)=RT
        ENDIF
 3007   CONTINUE
 3005   CONTINUE
C
C Now find the new position of the Eigenvalue R(I) and
C redirect it to R(INDX(I)):
        DO 3009 I=1,N,1
         DO 3011 J=1,N,1
        IF(RO(I).EQ.R(J)) INDX(J)=I
 3011 CONTINUE
 3009 CONTINUE
C
C Now move the Eigenvector coefficients to the correct place:
      DO 3013 J=1,N,1
      DO 3015 I=1,N,1
      EIGVEC(I,J)=V(I,INDX(J))
 3015 CONTINUE
 3013 CONTINUE
      RETURN
      END
C
C**********************************************************************C
C     PGM = INTPOL                            NCOF1      25.3.87       C
C                                                                      C
C     BERECHNET BCAL DURCH LINEARE U/O QUADRATISCHE INTERPOLATION      C
C     CALCULATES BCAL THROUGH LINEAR AND QUADRATIC REGRESSION          C
C**********************************************************************C
C
      SUBROUTINE INTPOL(QIP,LIP,WDH,ITER,FR,FLAS,BX,B0,DB,BOBS,
     &         BCAL,TR,ITC,EPSB,ITERA)
C
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL LIP ,QIP ,     WDH, ITER
      CHARACTER*3 UNIT
      REAL*8  FR(15),BX(15),DB(2),BQ(2)
      COMMON/EINEIT/ UNIT
      DATA VELC /2.99792458D04/
      DATA EPSF/1.0D-6/
C
C
      IF(QIP) THEN
C       QUADRATIC INTERPOLATION
        CALL LQIPOL(FR,FLAS,B0,DB(2),AA,AB,AC,BQ,NST,TR)
        IF(NST.EQ.1) THEN
          BCAL=BQ(1)
        ELSEIF(NST.EQ.2) THEN
          IF(DABS(BOBS-BQ(1)).LE.DABS(BOBS-BQ(2))) THEN
            BCAL=BQ(1)
          ELSE
            BCAL=BQ(2)
          ENDIF
        ELSE
C       NO FIELD FOUND
            BCAL=-471100.0D0
            LIP=.FALSE.
        ENDIF
C
        IF(LIP) THEN
          QIP=.FALSE.
          WDH=.TRUE.
          BX(1)=BCAL-DB(1)
          BX(3)=BCAL+DB(1)
          BX(2)=BCAL
        ELSE
          WDH=.FALSE.
        ENDIF
        RETURN
C
      ELSE
C       LINEAR INTERPOLATION
        BCAL=BX(2)
        FCAL=FR(2)
        FDIF=FLAS-FCAL
        DFI=FR(3)-FR(1)
        IF(UNIT.EQ.'GHz') THEN
          TR=0.5D3*DFI/DB(1)
        ELSE
          TR=0.5D0*VELC*DFI/DB(1)
        ENDIF
C          FACTOR = VEL OF LIGHT/2  (MHZ*CM)
C       TUNING RATE IN MHZ/GAUSS
        IF(DABS(DFI).GT.1.0D-10) THEN
          BCAL=BCAL+2*DB(1)*FDIF/DFI
         ELSE
        ENDIF
        ITC=ITC+1
        WDH=.FALSE.
C
         IF(ITER) THEN 
C ITERATIVE VERBESSERUNG:  
C       WDH LINEARE INTERPOL.
c       MIT NEUEM B
           IF(DABS(FDIF).GT.EPSF) THEN
             IF(DABS(BOBS-BCAL).GT.EPSB) THEN
               IF(ITC.LE.ITERA) THEN
                 BX(2)=BCAL
                 BX(1)=BCAL-DB(1)
                 BX(3)=BCAL+DB(1)
                 WDH=.TRUE.
               ENDIF
             ENDIF
           ENDIF
        ENDIF
C
      ENDIF
      RETURN
      END
C**********************************************************************C
C    PGM = LQIPOL       NCOF-VERSION              25. 3.87             C
C     QUADRATIC INTERPOLATION                                          C
C**********************************************************************C
      SUBROUTINE LQIPOL(FR,FREQ,H0,H1,A,B,C,FIELD,NST,TR)
C
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*3 UNIT
      REAL*8 FR(15),FREQ,H0,H1,A,B,C,TR
      REAL*8 FIELD(2)
      COMMON/EINEIT/UNIT
      DATA VELC /2.99792458D04/
C
      NST=0
      C=FR(2)-FREQ
      B=(FR(3)-FR(1))/(2*H1)
      A=(FR(1)+FR(3)-2*FR(2))/(2*H1**2)
C
      ISIGN=1
      IF(B.LT.0) ISIGN=-1
      ROOT=B**2-4.*A*C
      IF(ROOT.LT.0.D0)GO TO 251
      ROOT1=DSQRT(ROOT)
      DO 510 ISN=-1,1,2
      ROOT=(-B-ISN*ISIGN*ROOT1)/(2.*A)
      IF(DABS(ROOT).GT.H1)GO TO 510
        NST = NST+1
        ISGN=-ISN
        FIELD(NST)=H0+ROOT
C CALCULATE CORRECTION OF INTENSITY FOR TUNING RATE
        IF(UNIT.EQ.'GHz') THEN
          TR=(2.D0*A*ROOT+B)*1.D3
        ELSE
          TR=(2.D0*A*ROOT+B)*VELC
        ENDIF
C       DERIVATIVE OF FREQ WRT H
  510 CONTINUE
  251 CONTINUE
        RETURN
C       DEBUG SUBTRACE
        END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C    STOR  STORES THE EIGENVECTOR FOR LATER USE IN
C          THE INTENSITY CALCULATION
C
      SUBROUTINE STOR(IEV,XMF,IPAR)
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 L(60)
      DIMENSION S1(60),EIGVEC(60,60),QN(3,60),QN1(3,60)
      COMMON/LTO/EIGVEC,L
      COMMON/QNOS/QN
      COMMON/STR/QN1,S1,XMF1,IPAR1,JDIM1
      COMMON/DIM/JDIM
      XMF1=XMF
      JDIM1=JDIM
      IPAR1=IPAR
      DO 10 I=1,JDIM
      S1(I)=EIGVEC(I,IEV)
      DO 101 J=1,3
      QN1(J,I)=QN(J,I)
  101 CONTINUE
   10 CONTINUE
      RETURN
      END
      SUBROUTINE TRANS(IEV,IFLD,W)
C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C
C                      TESTED AGAINST HUNDA                         C
C    TRANS : CALCULATION OF RELATIVE INTENSITIES                    C
C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 L(60)
      DIMENSION S1(60),EIGVEC(60,60),QN(3,60),QN1(3,60)
      COMMON/LTO/EIGVEC,L
      COMMON/STR/QN1,S1,XM1,IPAR1,JDIM1
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/DIM/JDIM
      COMMON/QNOS/QN
      DATA ZERO,ONE,TWO /0.0D0,1.0D0,2.0D0/

      IF (IFLD.EQ.0) GO TO 40
C  DMF1 for the upper state M_F value, DMF2 for the lower state (stored)
      DMF1=XM
      DMF2=XM1
      P=DMF1-DMF2
      IF(DABS(P).GT.1.01) GOTO 50
C
   40 Y=ZERO
      DO 10 II=1,JDIM
      X=ZERO
      HH=EIGVEC(II,IEV)
      IF(DABS(HH).LT.1.D-10) GOTO 10
      XN1=QN(1,II)
      XJ1=QN(2,II)
      XF1=QN(3,II)
      DO 20 I=1,JDIM1
      DIJ=ZERO
      DELN=DABS(QN(1,II)-QN1(1,I))
      IF(DELN.GT.1.1) GOTO 20
      IF(XL.EQ.ZERO.AND.DELN.LT.0.9) GO TO 20
      XN2=QN1(1,I)
      XJ2=QN1(2,I)
      XF2=QN1(3,I)
      IF(DABS(XJ1-XJ2).GT.1.01) GOTO 20
      IF(DABS(XF1-XF2).GT.1.01) GOTO 20
      HHH=S1(I)
      IF(DABS(HHH).LT.1.D-10) GOTO 20
      T2=THREEJ(XN1,ONE,XN2,-XL,ZERO,XL)
      T3=SIXJ(XN1,XJ1,XS,XJ2,XN2,ONE)
      T4=SIXJ(XJ1,XF1,XI,XF2,XJ2,ONE)
      IEXP1= NINT(XJ1+XI+XF2+XN1+XS+XJ2+XN1-XL)
      EXP1=(-1)**IEXP1
      DIJ=EXP1*T2*T3*T4
      IF(IFLD.EQ.0) GOTO 31
c
      T1=THREEJ(XF1,ONE,XF2,-DMF1,P,DMF2)
      IEXPO=NINT(XF1-DMF1)
      EXPO=(-1)**IEXPO
      DIJ=DIJ*EXPO*T1
c
   31 CONTINUE
      XNJ2=DSQRT((TWO*XN2+ONE)*(TWO*XJ2+ONE)*(TWO*XF2+ONE))
      XX=HHH*DIJ*XNJ2
      X=X+XX
   20 CONTINUE
      XNJ1=DSQRT((TWO*XN1+ONE)*(TWO*XJ1+ONE)*(TWO*XF1+ONE))
      YY=X*HH*XNJ1
      Y=Y+YY
   10 CONTINUE
      W=Y**2
      RETURN
   50 CONTINUE
      WRITE(2,300)
  300 FORMAT(5X,' THE TRANSITION IS NOT DIPOLE-ALLOWED!!!')
      RETURN
C      DEBUG INIT
      END
C
      SUBROUTINE TRADEC(IEV,IFLD,W)
C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C
C                     NOT YET TESTED AGAINST DUPI                   C
C    TRADEC : CALCULATION OF RELATIVE INTENSITIES                   C
C             IN DE-COUPLED BASIS SET                               C
C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 L(60)
      DIMENSION S1(60),EIGVEC(60,60),QN(3,60),QN1(3,60)
      COMMON/LTO/EIGVEC,L
      COMMON/STR/QN1,S1,XMF1,IPAR1,JDIM1
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/DIM/JDIM
      COMMON/QNOS/QN
      DATA ZERO,ONE,TWO /0.0D0,1.0D0,2.0D0/

      P=XMF1-XM-XHFS
      IF(DABS(P).GT.1.01) GOTO 50
      IF(IPAR*IPAR1.EQ.1) GOTO 51
      DMF1=XM+XHFS
      DMF2=XMF1
      Y=ZERO
       DO 10 II=1,JDIM
       X=ZERO
       HH=EIGVEC(II,IEV)
       IF(DABS(HH).LT.1.D-10) GOTO 10
       XN1=QN(1,II)
       XJ1=QN(2,II)
       XMI1=QN(3,II)
       XMJ1=DMF1-XMI1
       DO 20 I=1,JDIM1
        DIJ=ZERO
        DELN=DABS(QN(1,II)-QN1(1,I))
        IF(DELN.GT.1.1) GOTO 20
        DELMI=DABS(QN(3,II)-QN1(3,I))
        IF(DELMI.GT.0.1) GOTO 20
        XN2=QN1(1,I)
        XJ2=QN1(2,I)
        IF(DABS(XJ1-XJ2).GT.1.01) GOTO 20
        XMI2=QN1(3,I)
        XMJ2=DMF2-XMI2
        HHH=S1(I)
        IF(DABS(HHH).LT.1.D-10) GOTO 20
        EXPOS=(-1)**NINT(XN2+XS+XJ1+1)
        EXPON=(-1)**NINT(XN2-XL)
        EXPOMJ=(-1)**NINT(XJ2-XMJ2)
        WIGN=THREEJ(XN2,ONE,XN1,-XL,ZERO,XL)
        WIGM=THREEJ(XJ2,ONE,XJ1,-XMJ2,XMJ2-XMJ1,XMJ1)
        WIG6N=SIXJ(XN2,XJ2,XS,XJ1,XN1,ONE)
        XN12=DSQRT(TWO*XN2+ONE)
        XJ12=DSQRT(TWO*XJ2+ONE)
        DIJ=EXPOS*EXPON*WIGN*WIG6N*XN12*XJ12
        DIJ=DIJ*WIGM*EXPOMJ
        IF(IFLD.EQ.0) THEN
          WRITE(2,*) ' NO INTENSITY CALCULATION IN DECOUPLED SCHEME YET'
          RETURN
        ENDIF
        XX=HHH*DIJ
        X=X+XX
   20  CONTINUE
       XJ11=DSQRT(TWO*XJ1+ONE)
       XN11=DSQRT(TWO*XN1+ONE)
       YY=X*HH*XJ11*XN11
       Y=Y+YY
   10 CONTINUE
      W=Y**2
      RETURN
   50 CONTINUE
      WRITE(2,300)
  300 FORMAT(5X,' THE TRANSITION IS NOT DIPOLE-ALLOWED!!!')
      RETURN
   51 CONTINUE
      WRITE(2,301)
  301 FORMAT(5X,' THE TRANSITION IS PARITY-FORBIDDEN!!!')
      RETURN
C      DEBUG INIT
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C    THE MATRIX REPRESENTATION OF THE MAGNETIC HYPERFINE INTERACTION IS 
C    CONSTRUCTED IN AN I-COUPLED BASIS SET
C
C
C
      SUBROUTINE HYPERF
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION HMAT(4,1830),QN(3,60)
C
      COMMON/HMATS/HMAT
      COMMON/QNOS/QN
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/DIM/JDIM
C
      DATA IA,IBF,IC,ID,IHSUM/1,2,3,4,4/
      DATA ZERO,HALF,ONE,TWO/0.0D0,0.5D0,1.0D0,2.0D0/
C
       IF(XI.GT.0.6D0) CALL QUADF
C
C CALCULATE QUANTITIES WHICH ARE NOT CHANGED WITHIN THE SUBROUTINE
C 
      XSRT=DSQRT(XS*(XS+ONE)*(TWO*XS+ONE))
      XIRT=DSQRT(XI*(XI+ONE)*(TWO*XI+ONE))
C BEGIN THE LOOP OVER ALL BASIS ELEMENTS
      DO 100 I1=1,JDIM
      DO 101 I2=1,I1
       ISYM=I1*(I1-1)/2+I2
C  SET THE ARRAYS TO ZERO
       DO 102 I3=1,IHSUM
        HMAT(I3,ISYM)=ZERO
  102  CONTINUE
C SELECTION RULES
       DELTAF=DABS(QN(3,I1)-QN(3,I2))
       IF(DELTAF.GT.0.1) GOTO 101
       DELTAN=DABS(QN(1,I1)-QN(1,I2))
       IF(DELTAN.GT.2.1) GOTO 101
       DELTAJ=QN(2,I1)-QN(2,I2)
       IF(DABS(DELTAJ).GT.1.1) GOTO 101
C
         XNV1=QN(1,I1)
         XNV2=QN(1,I2)
         XJV1=QN(2,I1)
         XJV2=QN(2,I2)
         XFV1=QN(3,I1)
C CALCULATION OF QUANTITIES WHICH OCCUR IN SEVERAL INTERACTIONS
         XJ12=DSQRT((TWO*XJV1+ONE)*(TWO*XJV2+ONE))
         XN12=DSQRT((TWO*XNV1+ONE)*(TWO*XNV2+ONE))
         WIGN1=THREEJ(XNV2,ONE,XNV1,-XL,ZERO,XL)
         WIGN2=THREEJ(XNV2,TWO,XNV1,-XL,ZERO,XL)
         WIG6F=SIXJ(XI,XJV2,XFV1,XJV1,XI,ONE)
         EXPOI=(-1)**NINT(XJV1+XI+XFV1)
         EXPON=(-1)**NINT(XNV2-XL)
C CALCULATE THE MATRIX
C
C  ORBITAL ANGULAR MOMENTUM-NUCLEAR SPIN I.L                 -IA-
           IF(XL.GT.0.1) THEN
             EXPOA=(-1)**NINT(XNV2+XS+XJV1+1)
             VAR=EXPOI*WIG6F
             VAR=VAR*EXPON*WIGN1*XN12
             VAR=VAR*SIXJ(XNV2,XJV2,XS,XJV1,XNV1,ONE)
             VAR=VAR*EXPOA*XJ12*XL*XIRT
             HMAT(IA,ISYM)=VAR
          ELSE
             HMAT(IA,ISYM)=ZERO
          ENDIF
C  SPIN-NUCLEAR SPIN  (FERMI CONTACT) I.S                    -IBF-
          IF(DELTAN.LT.0.1) THEN
            EXPOB=(-1)**NINT(XNV1+XS+XJV2+1)
            VAR=EXPOI*WIG6F*EXPOB*XJ12
            VAR=VAR*SIXJ(XS,XJV2,XNV1,XJV1,XS,ONE)
            VAR=VAR*XSRT*XIRT
          ELSE
            VAR=0.0
          ENDIF
          HMAT(IBF,ISYM)=VAR
C  SPIN-KERNSPIN ( DIPOL-DIPOL )  IZ.SZ-I.S/3                -IC-
C  SPIN-NUCLEAR SPIN (DIPOLE-DIPOLE)
          VARX=DSQRT(10.0D0/3.0D0)*EXPOI*WIG6F*XJ12*XN12
          VARX=VARX*XNINEJ(XNV2,XNV1,TWO,XS,XS,ONE,XJV2,XJV1,ONE)
          VARX=VARX*XSRT*XIRT
          VAR=VARX*EXPON*WIGN2
          HMAT(IC,ISYM)=-VAR    			     
CT  USED TEMPORARILY FOR C_I, NUCLEAR SPIN ROTATION COUPLING -ID-
CT  	IF(DELTAN.LT.0.1) THEN
CT	  EXPOB=(-1)**NINT(XNV2+XS+XJV1+ONE)
CT	  VAR=EXPOI*WIG6F*EXPOB*XJ12
CT	  VAR=VAR*SIXJ(XNV2,XJV2,XS,XJV1,XNV1,ONE)
CT	  VAR=VAR*XIRT*DSQRT(XNV1*(XNV1+ONE)*(TWO*XNV1+ONE))
        IF(DABS(XL-ONE).LT.0.1D0)THEN
          IVORZ=IPAR*(-1)**NINT(XNV1)
          VAR=VARX*EXPON*THREEJ(XNV2,TWO,XNV1,-XL,TWO,-XL)
          VAR=IVORZ*DSQRT(6.0D0)*VAR/TWO
	ELSE
	  VAR=ZERO
	ENDIF
	  HMAT(ID,ISYM)=VAR
  101 CONTINUE
  100 CONTINUE
C      DO 300 I1=1,IHSUM
C       WRITE(2,*) 'HYPERF-WW ',I1
C       DO 301 I2=1,JDIM
C        WRITE(2,302)(HMAT(I1,(I2*(I2-1)/2+I3)),I3=1,I2)
C  302   FORMAT('0',6(D17.10,3X))
C  301  CONTINUE
C  300 CONTINUE
      RETURN
      END

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C    THE MATRIX REPRESENTATION OF THE MAGNETIC HYPERFINE 
C    INTERACTION IS CONSTRUCTED IN AN I-DECOUPLED BASIS SET
C
C
      SUBROUTINE HYPDEC
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION HMAT(4,1830),QN(3,60)
C
      COMMON/HMATS/HMAT
      COMMON/QNOS/QN
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
C                                 XHFS=XMI,XM=XMJ
      COMMON/DIM/JDIM
C
      DATA IA,IBF,IC,ID,IHSUM/1,2,3,4,4/
      DATA ZERO,HALF,ONE,TWO/0.0D0,0.5D0,1.0D0,2.0D0/
C
      IF(XI.GT.0.6D0) CALL QUADEC
C 
C CALCULATION OF QUANTITIES WHICH ARE NOT CHANGED WITHIN THE SUBROUTINE 
      XMF=XM+XHFS
      XSRT=DSQRT(XS*(XS+ONE)*(TWO*XS+ONE))
      XIRT=DSQRT(XI*(XI+ONE)*(TWO*XI+ONE))
C BEGIN THE LOOP OVER ALL BASIS STATES
      DO 100 I1=1,JDIM
      DO 101 I2=1,I1
       ISYM=I1*(I1-1)/2+I2
C SET MATRIX ELEMENTS TO ZERO
       DO 102 I3=1,IHSUM
        HMAT(I3,ISYM)=ZERO
  102  CONTINUE
C SELECTION RULES
       DELTAI=DABS(QN(3,I1)-QN(3,I2))
       IF(DELTAI.GT.1.1) GOTO 101
       DELTAN=DABS(QN(1,I1)-QN(1,I2))
       IF(DELTAN.GT.2.1) GOTO 101
       DELTAJ=QN(2,I1)-QN(2,I2)
       IF(DABS(DELTAJ).GT.1.1) GOTO 101
C
         XNV1=QN(1,I1)
         XNV2=QN(1,I2)
         XJV1=QN(2,I1)
         XJV2=QN(2,I2)
         XMIV1=QN(3,I1)
         XMJV1=XMF-XMIV1
         XMIV2=QN(3,I2)
         XMJV2=XMF-XMIV2
C CALCULATION OF QUANTITIES WHICH OCCUR IN SEVERAL INTERACTIONS
         XJ12=DSQRT((2.*XJV1+1.)*(2.*XJV2+1.))
         XN12=DSQRT((2.*XNV1+1.)*(2.*XNV2+1.))
         WIGN1=THREEJ(XNV2,1.0D0,XNV1,-XL,0.0D0,XL)
         WIGN2=THREEJ(XNV2,2.0D0,XNV1,-XL,0.0D0,XL)
         WIGMI=THREEJ(XI,1.D0,XI,-XMIV2,XMIV2-XMIV1,XMIV1)
         WIGMJ=THREEJ(XJV2,1.D0,XJV1,-XMJV2,XMJV2-XMJV1,XMJV1)
         EXPOI=(-1)**NINT(XJV2+XI-XMJV1-XMIV2)
         FACF=EXPOI*WIGMJ*WIGMI
         EXPON=(-1)**NINT(XNV2-XL)
C CALCULATE THE MATRIX
C
C  ORBITAL ANGULAR MOMENTUM-NUCLEAR SPIN
           IF(XL.GT.0.1) THEN
             EXPOA=(-1)**NINT(XNV2+XS+XJV1+1)
             VAR=FACF
             VAR=VAR*EXPON*WIGN1*XN12
             VAR=VAR*SIXJ(XNV2,XJV2,XS,XJV1,XNV1,1.0D0)
             VAR=VAR*EXPOA*XJ12*XL*XIRT
             HMAT(IA,ISYM)=VAR
          ELSE
             HMAT(IA,ISYM)=0.0
          ENDIF
C  SPIN-NUCLEAR SPIN  (FERMI CONTACT) I.S                    -IBF-
          IF(DELTAN.LT.0.1) THEN
            EXPOB=(-1)**NINT(XNV1+XS+XJV2+1)
            VAR=FACF*EXPOB*XJ12
            VAR=VAR*SIXJ(XS,XJV2,XNV1,XJV1,XS,1.D0)
            VAR=VAR*XSRT*XIRT
          ELSE
            VAR=0.0
          ENDIF
          HMAT(IBF,ISYM)=VAR
C  SPIN-NUC SPIN (DIPOLE-DIPOLE) IZ.SZ-I.S/3                  -IC-
          VARX=DSQRT(10.0D0/3.0D0)*FACF*XJ12*XN12
          VARX=VARX*XNINEJ(XNV2,XNV1,TWO,XS,XS,ONE,XJV2,XJV1,ONE)
          VARX=VARX*XSRT*XIRT
          VAR=VARX*EXPON*WIGN2
          HMAT(IC,ISYM)=-VAR
C  -0.5D(SPIN-NUC SPIN DIPOLAR COUPLING, PI STATES ONLY)    -ID-
          IF(XL.EQ.ONE) THEN
            IVORZ=IPAR*(-1)**NINT(XNV1)
            VAR=VARX*EXPON*THREEJ(XNV2,TWO,XNV1,-XL,TWO,-XL)
            VAR=IVORZ*DSQRT(6.0D0)*VAR/TWO
          ENDIF
            HMAT(ID,ISYM)=VAR  
  101 CONTINUE
  100 CONTINUE
C      DO 300 I1=1,IHSUM
C       WRITE(2,*) 'HYPERF-WW ',I1
C       DO 301 I2=1,JDIM
C        WRITE(2,302)(HMAT(I1,(I2*(I2-1)/2+I3)),I3=1,I2)
C  302   FORMAT('0',6(D17.10,3X))
C  301  CONTINUE
C  300 CONTINUE
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C    CALCULATION OF THE ELECTRIC QUADRUPOLE HYPERFINE MATRIX (HUNDB)
C
C
C
      SUBROUTINE QUADF
      IMPLICIT REAL*8 (A-H,O-Z), INTEGER*4 (I-N)
      DIMENSION EQMAT(2,1830),QN(3,60)
C
      COMMON/EQMATS/EQMAT
      COMMON/QNOS/QN
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/DIM/JDIM
C
      DATA IQ0,IQ2,IQSUM/1,2,2/
      DATA ZERO,HALF,ONE,TWO /0.0D0,0.5D0,1.0D0,2.0D0/
C
C SET THE MATRICES TO ZERO
       DO 333 I1=1,1830
        DO 102 I3=1,IQSUM
         EQMAT(I3,I1)=ZERO
  102   CONTINUE
  333  CONTINUE
C CALCULATION OF QUANTITIES WHICH ARE NOT CHANGED IN THE COURSE OF THE
C SUBROUTINE
 
	TWOI=TWO*XI
      XI2RT=0.25D0*DSQRT((TWOI+3.0D0)*(TWOI+TWO)*(TWOI+ONE)/
     & (TWOI*(TWOI-ONE)))
C LOOP OVER ALL BASIS STATES
      DO 100 I1=1,JDIM
      DO 101 I2=1,I1
C SELECTION RULES
       ISYM=I1*(I1-1)/2+I2
       DELTAF=DABS(QN(3,I1)-QN(3,I2))
       IF(DELTAF.GT.0.1D0) GOTO 101
       DELTAN=DABS(QN(1,I1)-QN(1,I2))
       IF(DELTAN.GT.2.1D0) GOTO 101
       DELTAJ=QN(2,I1)-QN(2,I2)
       IF(DABS(DELTAJ).GT.2.1D0) GOTO 101
C
         XNV1=QN(1,I1)
C      WRITE(2,601) XNV1
C  601 FORMAT( ' XNV1= ',F4.1)
        XNV2=QN(1,I2)
C      WRITE(2,602) XNV2
C  602 FORMAT( ' XNV2= ',F4.1)
C      WRITE(2,603) XI
C  603 FORMAT( ' XI= ',F4.1)
         XJV1=QN(2,I1)
         XJV2=QN(2,I2)
         XHFSV1=QN(3,I1)
C      WRITE(2,600) XHFSV1
C  600 FORMAT( ' XHFSV1= ',F4.1)
C CALCULATION OF QUANTITIES WHICH OCCUR IN SEVERAL EXPRESSIONS
         XJ12=DSQRT((TWO*XJV1+ONE)*(TWO*XJV2+ONE))
         XN12=DSQRT((TWO*XNV1+ONE)*(TWO*XNV2+ONE))
         EXPON=(-1)**NINT(XNV2-XL+XJV1+XI+XHFSV1+XNV2+XS+XJV1)
         WIG2O=THREEJ(XNV2,TWO,XNV1,-XL,ZERO,XL)
         WIG26F=SIXJ(XJV2,XI,XHFSV1,XI,XJV1,TWO)
         WIG26S=SIXJ(XNV2,XJV2,XS,XJV1,XNV1,TWO)
C  610 FORMAT( ' WIG26F= ',F20.10)
C      WRITE(2,610) WIG26F
C     CALCULATION OF THE ELECTRIC QUADRUPOLE INTERACTION
C     MATRIX ELEMENTS OF eq0Q             -IQ0-
        VAR=EXPON*XJ12*XN12*XI2RT*WIG2O*WIG26F*WIG26S
        EQMAT(IQ0,ISYM)=VAR
C
C    MATRIX ELEMENTS OF eq2Q FOR PI STATES             -IQ2-
C
        IF(DABS(XL-ONE).LT.0.25D0) THEN
C PARITY PHASE FACTOR FOR HUND'S CASE(B) NOT YET CHECKED
          IVORZ=IPAR*(-1)**NINT(XNV1)
          VAR=EXPON*XJ12*XN12*XI2RT*WIG26F*WIG26S
          VAR=VAR*IVORZ*THREEJ(XNV2,TWO,XNV1,-XL,TWO,-XL)
          VAR=VAR/DSQRT(6.0D0)
          EQMAT(IQ2,ISYM)=VAR
        ENDIF
  101 CONTINUE
  100 CONTINUE
C      DO 300 I1=1,IQSUM
c       WRITE(2,*) 'HYPERF-WW ',I1
C       DO 301 I2=1,JDIM
C        WRITE(2,302)(EQMAT(1,(I2*(I2-1)/2+I3)),I3=1,I2)
C  302   FORMAT(/' ',6(D17.10,3X))
C  301  CONTINUE
C  300 CONTINUE
      RETURN
      END
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C    THE MATRIX REPRESENTATION OF THE ELECTRIC QUADRUPOLE HYPERFINE
C    INTERACTION IS SET UP -IN A DECOUPLED REPRESENTATION (hundB)
C
C
      SUBROUTINE QUADEC
      IMPLICIT REAL*8 (A-H,O-Z),INTEGER*4 (I-N)
      DIMENSION EQMAT(2,1830),QN(3,60)
C
      COMMON/EQMATS/EQMAT
      COMMON/QNOS/QN
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
C                                 XHFS=XMI,XM=XMJ
      COMMON/DIM/JDIM
C
      DATA IQ0,IQ2,IQSUM/1,2,2/
      DATA ZERO,HALF,ONE,TWO /0.0D0,0.5D0,1.0D0,2.0D0/
C
      IF(DABS(XI).LT.0.9D0) RETURN
C SET THE MATRIX TO ZERO
       DO 333 I1=1,1830
        DO 102 I3=1,IQSUM
         EQMAT(I3,I1)=ZERO
  102   CONTINUE
  333  CONTINUE
C CALCULATE QUANTITIES WHICH ARE NOT CHANGED WITHIN THE SUBROUTINE
C 
	TWOI=TWO*XI
      XI2RT=0.25D0*DSQRT((TWOI+3.0D0)*(TWOI+TWO)*(TWOI+ONE)/
     & (TWOI*(TWOI-ONE)))
      XMF=XHFS+XM
C BEGINNING THE LOOP OVER ALL BASIS STATES
      DO 100 I1=1,JDIM
      DO 101 I2=1,I1
C SELECTION RULES
       ISYM=I1*(I1-1)/2+I2
       DELTAI=DABS(QN(3,I1)-QN(3,I2))
       DELTAN=DABS(QN(1,I1)-QN(1,I2))
       DELTAJ=QN(2,I1)-QN(2,I2)
       IF(DELTAI.GT.2.1D0) GOTO 101
       IF(DELTAN.GT.2.1D0) GOTO 101
       IF(DABS(DELTAJ).GT.2.1D0) GOTO 101
         XNV1=QN(1,I1)
         XNV2=QN(1,I2)
         XJV1=QN(2,I1)
         XJV2=QN(2,I2)
         XMIV1=QN(3,I1)
         XMIV2=QN(3,I2)
         XMJV1=XMF-XMIV1
         XMJV2=XMF-XMIV2
C FOR THE EL. QUADRUPOLE CALCULATION
         WIG2I=THREEJ(XI,2.D0,XI,-XMIV2,XMIV2-XMIV1,XMIV1)
         WIG2M=THREEJ(XJV2,2.D0,XJV1,-XMJV2,XMJV2-XMJV1,XMJV1)
         WIG2O=THREEJ(XNV2,2.D0,XNV1,-XL,ZERO,XL)
         XJ12=DSQRT((TWO*XJV1+ONE)*(TWO*XJV2+ONE))
         XN12=DSQRT((TWO*XNV1+ONE)*(TWO*XNV2+ONE))
         EXPO1=(-1)**NINT(XJV2-XMJV1+XI-XMIV2+XNV2-XL+XNV2+XS+XJV1)
	 WIG26S=SIXJ(XNV2,XJV2,XS,XJV1,XNV1,TWO)
C
C BERECHNUNG DER GROESSEN, DIE IN MEHREREN WW AUFTAUCHEN
C
C  CALCULATION OF THE QUADRUPOLE INTERACTION                   -IQ0-
C  MATRIX ELEMENTS OF eq0Q
        VAR=EXPO1*XJ12*XN12*WIG2I*WIG2M*WIG2O*WIG26S*XI2RT
        EQMAT(IQ0,ISYM)=VAR
C
C    MATRIX ELEMENTS OF eq2Q                                   -IQ2-
C
        IF(DABS(XL-ONE).LT.0.25D0) THEN
          IVORZ=IPAR*(-1)**NINT(XNV1)
          VAR=EXPO1*XJ12*XN12*WIG2I*WIG2M*WIG26S*XI2RT
          VAR=VAR*IVORZ*THREEJ(XNV2,TWO,XNV1,-XL,TWO,-XL)
          VAR=VAR/DSQRT(6.0D0)
          EQMAT(IQ2,ISYM)=VAR
        ENDIF
  101 CONTINUE
  100 CONTINUE
C     DO 300 I1=1,IQSUM
C      WRITE(2,*) 'ELQUAD-WW DECOUPLED',I1
C      DO 301 I2=1,JDIM
C       WRITE(2,302)(EQMAT(I1,(I2*(I2-1)/2+I3)),I3=1,I2)
C 302   FORMAT(/' ',6(D17.10,3X))
C 301  CONTINUE
C 300 CONTINUE
      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE DOUBLE
C  major modification  o_D,p_D and q_D added   JMB 4-1-97
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION DMAT(6,1830),QN(3,60)
C
      COMMON/DMATS/DMAT
C DMAT CONTAINS THE DERIVED MATRIX
      COMMON/QNOS/QN
C QN CONTAINS THE BASIS
      COMMON/DIM/JDIM
C JDIM IS THE DIMENSION OF THE BASIS
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
C THE ACTUAL QUANTUM NUMBERS
C EXPLICITLY DECLARE USEFUL NUMBERS:
      DATA ZERO,HALF,ONE,TWO/0.0D0,0.5D0,1.0D0,2.0D0/
      DATA THREE/3.0D0/
C
      DATA IO,IP,IQ,IOD,IPD,IQD,ISUM/1,2,3,4,5,6,6/
      IF(IPAR.EQ.0) RETURN
      XS11=XS*(XS+ONE)
      XSRT=DSQRT(XS11*(TWO*XS+ONE))
      XDSRT=DSQRT((TWO*XS+THREE)*(TWO*XS+TWO)*(TWO*XS+ONE)*TWO*
     &                   XS*(TWO*XS-ONE)) /TWO/DSQRT(6.0D0)

      DO 100 I1=1,JDIM
      DO 100 I2=1,I1
       ISYM=I1*(I1-1)/2 +I2
       DO 102 I3=1,ISUM
        DMAT(I3,ISYM)=ZERO
102       CONTINUE
C  SELECTION RULES
         DELTAJ=DABS(QN(2,I1)-QN(2,I2))
         IF(DELTAJ.GT.1.D-9) GOTO 100
         DELTAF=DABS(QN(3,I1)-QN(3,I2))
         IF(DELTAF.GT.1.D-9) GOTO 100
         DELTAN=DABS(QN(1,I1)-QN(1,I2))
         IF(DELTAN.GT.2.1D0) GOTO 100
C
         XNV1=QN(1,I1)
         XNV2=QN(1,I2)
         XJV=QN(2,I1)
         XJ11=XJV*(XJV+ONE)
         XN12=DSQRT((TWO*XNV2+ONE)*(TWO*XNV1+ONE))
         XN11=XNV1*(XNV1+ONE)
         XN22=XNV2*(XNV2+ONE)
         XNRT=DSQRT(XN11*(TWO*XNV1+ONE))
         XDNRT=DSQRT((TWO*XNV1+THREE)*(TWO*XNV1+TWO)*(TWO*XNV1+ONE)*TWO*
     &                   XNV1*(TWO*XNV1-ONE))
        IPARITY=(-1)**NINT(XNV1)
C CALCULATE THE MATRIX REPRESENTATION
C
C  Q TERM 0.5*((LAMDA+)**2 (N-)**2)+(LAMBDA-)**2 (N+)**2)    -q-
C
          IF(DELTAN.LT.0.1D0) THEN
           VAR = (-1)**NINT(XNV2-XL)*THREEJ(XNV2,TWO,XNV1,-XL,TWO,-XL)
           VAR = (HALF/DSQRT(6.0D0))*XDNRT*VAR
           DMAT(IQ,ISYM)=IPAR*IPARITY*VAR
C          WRITE(2,*) 'XNV1=',XNV1,'XNV2=',XNV2
C          WRITE(2,*) ISYM, DMAT(IQ,ISYM)
          ENDIF
C
C  TERM N**2 ((LAMDA+)**2 (N-)**2)+(LAMBDA-)**2 (N+)**2)    -q_D-
C
         IF(DELTAN.LT.0.1D0) THEN
          DMAT(IQD,ISYM)=DMAT(IQ,ISYM)*XN11
         ENDIF
C         WRITE(2,*) 'XNV1=',XNV1,'XNV2=',XNV2
C         WRITE(2,*) ISYM, DMAT(IQD,ISYM)
C
 
C   TERM -0.5*((LAMDA+)**2 (S-) J-)+(LAMBDA-)**2 (S+) J+)  -(p)-
C
c     WRITE(2,*) 'IP:',XNV1,XNV2,XJV
          IF(XS.LT.HALF) GOTO 100
        IF(DELTAN.LT.1.1D0) THEN
          VAR=(-1)**NINT(XJV+XS+XL)*XN12
          VAR=VAR*XNRT*XSRT
          VAR = VAR*THREEJ(XNV2,TWO,XNV1,-XL,TWO,-XL)
          VAR=VAR*DSQRT(5.0D0)*SIXJ(XNV1,XS,XJV,XS,XNV2,ONE)
          VAR=VAR*SIXJ(ONE,XNV1,XNV1,XNV2,TWO,ONE)
          DMAT(IP,ISYM)=-IPAR*IPARITY*VAR
C         WRITE(2,*) 'XNV1=',XNV1,'XNV2=',XNV2,'J=',XJV
C
C   HERM AVERAGE OF N**2 & -0.5*((LAMDA+)**2 (N-)(S-))+(LAMBDA-)**2 (N+)(S+))  
C                                                              -(p_D)-
C
	   DMAT(IPD,ISYM) = DMAT(IP,ISYM)*HALF*(XN11+XN22)
	ENDIF
 
C   TERM 0.5*((LAMDA+)**2 (S-)**2)+(LAMBDA-)**2 (S+)**2)  -(o)-
          IF(XS.LT.ONE) GO TO 100 
          VAR=(-1)**NINT(XNV1+XS+XJV+XNV2-XL)*XN12
          VAR=VAR*XDSRT
          VAR = VAR*SIXJ(XS,XNV2,XJV,XNV1,XS,TWO)
          VAR = VAR*THREEJ(XNV2,TWO,XNV1,-XL,TWO,-XL)
          DMAT(IO,ISYM)=IPAR*IPARITY*VAR
C         WRITE(2,*) 'XNV1=',XNV1,'XNV2=',XNV2
C         WRITE(2,*) ISYM, DMAT(IOP,ISYM)

  100   CONTINUE
C       WRITE(2,*) 'DOUBLING:'
C       DO 222 II=1,ISUM
C       WRITE(2,*) 'II=',II
C       DO 222 I1=1,JDIM
C       WRITE(2,*) (DMAT(II,I1*(I1-1)/2+I2),I2=1,I1)
C  222 CONTINUE
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C    LAMBDA -DOUBLING IN DELTA STATES
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE DOUBDE
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION DDMAT(3,1830),QN(3,60)
C
      COMMON/DDMATS/DDMAT
C QMAT CONTAINS THE DERIVED MATRIX
      COMMON/QNOS/QN
C QN CONTAINS THE BASIS
      COMMON/DIM/JDIM
C JDIM = DIMENSION OF THE BASIS
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
C THE ACTUAL QUANTUM NUMBERS
C
      DATA IQ,IP4Q,ISUM/1,2,2/
      WRITE(2,*) ' DUBDE NOT YET PROGRAMMED FOR HUND (B) '
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCVC
C    ZEEMAN
C  DIESES UNTERPROGRAMM STELLT DIE ABLEITUNGSMATRIZEN FUER
C  ZEEMANMATRIX AUF.
      SUBROUTINE ZEEMAN
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION ZMAT(7,1830),QN(3,60)
      CHARACTER*3 UNIT
C
      COMMON/ZMATS/ZMAT
      COMMON/QNOS/QN
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/DIM/JDIM
      COMMON/EINEIT/UNIT
C
      DATA IGS,IGL,IGR,IGLS,IGLP,IGRP,IGI,ISUM/1,2,3,4,5,6,7,7/
      XMF=XM
      BETA=4.6686452D-5
C  OLD VALUE FOR BOHR MAGNETON
C      BETA=4.6686041D-5
      IF(UNIT.EQ.'GHz') BETA=BETA*29.9792458D0
C  SET THE MATRIX TO ZERO
      DO 10 I1=1,1830
      DO 10 I2=1,ISUM
          ZMAT(I2,I1)=0.0
   10 CONTINUE
C CALCULATION OF QUANITITES WHICH DO NOT CHANGE WITHIN THIS SUBROUTINE
      XSRT=DSQRT(XS*(XS+1.)*(2.*XS+1.))
C BEGIN THE LOOP OVER THE BASIS ELEMENTS
      DO 100 I1=1,JDIM
      DO 101 I2=1,I1
C SELECTION RULES
       DELTAN=DABS(QN(1,I1)-QN(1,I2))
       IF(DELTAN.GT.2.1) GOTO 101
       DELTAJ=DABS(QN(2,I1)-QN(2,I2))
       IF(DELTAJ.GT.1.1) GOTO 101
       DELTAF=DABS(QN(3,I1)-QN(3,I2))
       IF(DELTAF.GT.1.1) GOTO 101
C
         XNV1=QN(1,I1)
         XNV2=QN(1,I2)
         XJV1=QN(2,I1)
         XJV2=QN(2,I2)
         XFV1=QN(3,I1)
         XFV2=QN(3,I2)
C BERECHNUNG DER GROESSEN, DIE IN MEHREREN WW AUFTAUCHEN
         XJ12=DSQRT((2.*XJV1+1.)*(2.*XJV2+1.))
         XN12=DSQRT((2.*XNV1+1.)*(2.*XNV2+1.))
         XF12=DSQRT((2.*XFV1+1.)*(2.*XFV2+1.))
         EXPOM=(-1)**NINT(XFV2-XMF)
         EXPOF=(-1)**NINT(XJV2+XI+XFV1+1)
         WIG6F=SIXJ(XJV2,XFV2,XI,XFV1,XJV1,1.D0)
         WIGMF=THREEJ(XFV2,1.D0,XFV1,-XMF,0.D0,XMF)
         EXPON=(-1)**NINT(XNV2-XL)
         ISYM=I1*(I1-1)/2+I2
C CALCULATE THE MATRIX
C
C  MAGNETIC FIELD-SPIN      SZ                       -IGS-
          IF(DELTAN.LT.0.1) THEN
            EXPO=(-1)**NINT(XNV1+XS+XJV2+1)
            WIG6S=SIXJ(XS,XJV2,XNV1,XJV1,XS,1.D0)
            VAR=EXPOM*WIGMF*EXPOF*WIG6F*XF12
            VAR=VAR*EXPO*WIG6S*XJ12*XSRT*BETA
          ELSE
            VAR=0.0
          ENDIF
          ZMAT(IGS,ISYM)=VAR
C  MAG FIELD-ORB ANG MOM INTERACTION  LZ             -IGL-
C  NOCH NICHT IN ENTKOPPELTER DARSTELLUNG BERECHNET
C MARTINA:
C        IF(XL.EQ.0.0D0) GO TO 99
C         SUM=0.0D0
C         IMULT=2*XS
C         DO  98 II=0,IMULT
C          XMXS= (IMULT/2.0) - II
C          XOME=XMXS+XL
C          VAR= (-1)**NINT(XNV1+XNV2-IMULT+(2*XOME))
C          VAR= VAR * XN12 * THREEJ(XJV1,XS,XNV1,XOME, -XMXS,-XL)
C          VAR= VAR * THREEJ(XJV2,XS,XNV2,XOME,-XMXS,-XL)
C          EXPO=(-1)**NINT(XJV1-XM+XJV1-XOME)
C          WGN3A=THREEJ(XJV1,1.D0,XJV2,-XM,0.D0,XM)
C          WGN3B=THREEJ(XJV1,1.D0,XJV2,-XOME,0.D0,XOME)
C          VAR=VAR*EXPO*WGN3A*WGN3B*XJ12*XL
C          SUM=SUM + VAR
C   98     CONTINUE
C   99     CONTINUE
C          ZMAT(IGL,ISYM)=SUM*BETA
 
          IF(XL.EQ.0.0D0) GOTO 97
          VAR=EXPOM*EXPOF*EXPON*(-1)**NINT(XNV2+XS+XJV1+1)*XL
          VAR=VAR*XN12*WIGMF*WIG6F*XF12*XJ12
          VAR=VAR*SIXJ(XNV2,XJV2,XS,XJV1,XNV1,1.0D0)
          VAR=VAR*THREEJ(XNV2,1.0D0,XNV1,-XL,0.0D0,XL)
   97     ZMAT(IGL,ISYM)=VAR * BETA
C         WRITE(2,*) 'N1=',XNV1,'N2=',XNV2,'J1=',XJV1,'J2=',XJV2
C         WRITE(2,*) 'XM=', XM, 'F1=',XFV1,'F2=',XFV2,ISYM,ZMAT(IGL,ISYM)
 
C  MAG FIELD-ROT INTERACTION  NZ                     -IGR-
          IF(DELTAN.LT.0.1) THEN
            EXPOR=(-1)**NINT(XNV2+XS+XJV1+1)
            WIG6N=SIXJ(XNV1,XJV2,XS,XJV1,XNV1,1.D0)
            XNRT=DSQRT(XNV1*(XNV1+1)*(2.*XNV1+1))
            VAR=EXPOR*WIG6N*XNRT*XJ12
            VAR=VAR*EXPOM*WIGMF*EXPOF*WIG6F*XF12*BETA
          ELSE
            VAR=0.0
          ENDIF
          ZMAT(IGR,ISYM)=-VAR
C CORRECTION TERM         GLS                          -IGLS-
C NOCH NICHT IN ENTKOPPELTER DARSTELLUNG BERECHNET
C    'VAR' WIRD UEBERNOMMEN AUS S.Z
            WIG9K=XNINEJ(XNV2,XNV1,2.D0,XS,XS,1.D0,XJV2,XJV1,1.D0)
            WIG3N=THREEJ(XNV2,2.D0,XNV1,-XL,0.0D0,XL)
            WIG3K=THREEJ(1.D0,2.D0,1.D0,0.D0,0.D0,0.D0)
            VARK=5.*WIG3N*WIG3K*WIG9K
            IF(DELTAN.LT.0.1) THEN
              WIG9K=XNINEJ(XNV2,XNV1,0.D0,XS,XS,1.D0,XJV2,XJV1,1.D0)
              WIG3N=THREEJ(XNV2,0.D0,XNV1,-XL,0.0D0,XL)
              WIG3K=THREEJ(1.D0,0.D0,1.D0,0.D0,0.D0,0.D0)
              VARK=VARK+WIG9K*WIG3N*WIG3K
            ENDIF
            VARK=VARK*EXPON*XN12*XJ12*XSRT
            VARK=VARK*EXPOM*WIGMF*EXPOF*WIG6F*XF12*BETA
            VAR=ZMAT(IGS,ISYM)+VARK
            ZMAT(IGLS,ISYM)=VAR
C PARAMETERS GLP,GRP,GI NOT YET PROGRAMMED
  101 CONTINUE
  100 CONTINUE
      DO 300 I1=1,ISUM
c       WRITE(2,*) ' ZEEMAN WW ',I1
c       DO 301 I2=1,JDIM
c        WRITE(2,302)(ZMAT(I1,(I2*(I2-1)/2+I3)),I3=1,I2)
c  302   FORMAT('0',6(D17.10,3X))
c  301  CONTINUE
  300 CONTINUE
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCVC
C
C    ZEEDEC
C
C  DIESES UNTERPROGRAMM STELLT DIE ABLEITUNGSMATRIZEN FUER
C  ZEEMANMATRIX AUF.  IN ENTKOPPELTER DARSTELLUNG.
C
      SUBROUTINE ZEEDEC
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION ZMAT(7,1830),QN(3,60)
      CHARACTER*3 UNIT
C
      COMMON/ZMATS/ZMAT
      COMMON/QNOS/QN
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
C                               XHFS=XMI,XM=XMJ
      COMMON/DIM/JDIM
      COMMON/EINEIT/UNIT
C
      DATA IGS,IGL,IGR,IGLS,IGLP,IGRP,IGI,ISUM/1,2,3,4,5,6,7,7/
      DATA ZERO,HALF,ONE,TWO,THREE,FIVE/0.0D0,0.5D0,1.0D0,2.0D0,3.0D0,
     &5.0D0/
      BETA=4.6686452D-5
C  OLD VALUE FOR BOHR MAGNETON
C      BETA=4.6686041D-5
      IF(UNIT.EQ.'GHz') BETA=BETA*29.9792458D0
      XMF=XM+XHFS
C  SET THE MATRIX TO ZERO
      DO 10 I1=1,1830
      DO 10 I2=1,ISUM
          ZMAT(I2,I1)=ZERO
   10 CONTINUE
C CALCULATION OF QUANTITIES WHICH DO NOT CHANGE WITHIN SUBROUTINE
      XSRT=DSQRT(XS*(XS+ONE)*(TWO*XS+ONE))
C BEGIN THE LOOP OVER THE MATRIX ELEMENTS
      DO 100 I1=1,JDIM
      DO 101 I2=1,I1
C SELECTION RULES FOR THE MATRIX ELEMENTS
       DELTAN=DABS(QN(1,I1)-QN(1,I2))
       IF(DELTAN.GT.2.1) GOTO 101
       DELTAJ=DABS(QN(2,I1)-QN(2,I2))
       IF(DELTAJ.GT.1.1) GOTO 101
       DELTAI=DABS(QN(3,I1)-QN(3,I2))
       IF(DELTAI.GT.0.1) GOTO 101
C
         XNV1=QN(1,I1)
         XNV2=QN(1,I2)
         XJV1=QN(2,I1)
         XJV2=QN(2,I2)
         XMIV1=QN(3,I1)
         XMJV1=XMF-XMIV1
C CALCULATION OF QUANTITIES USED IN SEVERAL INTERACTIONS
         XJ12=DSQRT((TWO*XJV1+ONE)*(TWO*XJV2+ONE))
         XN12=DSQRT((TWO*XNV1+ONE)*(TWO*XNV2+ONE))
         EXPOM=(-1)**NINT(XJV2-XMJV1)
         WIGMJ=THREEJ(XJV2,ONE,XJV1,-XMJV1,ZERO,XMJV1)
         EXPON=(-1)**NINT(XNV2-XL)
         XNRT1=DSQRT(XNV1*(XNV1+ONE)*(TWO*XNV1+ONE))
         ISYM=I1*(I1-1)/2+I2
C CALCULATE THE MATRIX
C
C  MAG FIELD-SPIN INTERACTION SZ                     -IGS-
          IF(DELTAN.LT.0.1) THEN
            EXPO=(-1)**NINT(XNV1+XS+XJV2+1)
            WIG6S=SIXJ(XS,XJV2,XNV1,XJV1,XS,ONE)
            VAR=EXPOM*WIGMJ
            VAR=VAR*EXPO*WIG6S*XJ12*XSRT*BETA
          ELSE
            VAR=ZERO
          ENDIF
          ZMAT(IGS,ISYM)=VAR
C  MAG FIELD-ORB ANG MOM INTERACTION  LZ             -IGL-
C NEW CODE TV 29/10/92
          VAR=0.0D0
          IF(XL.LT.0.1) GO TO 95
          VAR=EXPOM*(-1)**NINT(XS+XJV1+1+XL)*XJ12*XN12
C           WRITE(2,*) 'THREEJ=',THREEJ(XNV2,1.0D0,XNV1,-XL,0.0D0,XL)
          VAR=VAR*WIGMJ*THREEJ(XNV2,ONE,XNV1,-XL,ZERO,XL)
          VAR=VAR*SIXJ(XNV2,XJV2,XS,XJV1,XNV1,ONE)*XL
C   95       ZMAT(IGL,ISYM)=VAR
C           WRITE(2,*) 'ZMAT=',VAR
   95     ZMAT(IGL,ISYM)=VAR*BETA
 
c         WRITE(2,*) 'N1=',XNV1,'N2=',XNV2,'J1=',XJV1,'J2=',XJV2
c         WRITE(2,*) 'MJ1=',XMJV1,ISYM, ZMAT(IGL,ISYM)
C  MAGNETIC FIELD-ROTATION INTERACTION  NZ           -IGR-
          IF(DELTAN.LT.0.1) THEN
            EXPOR=(-1)**NINT(XNV2+XS+XJV1+1)
            WIG6N=SIXJ(XNV1,XJV2,XS,XJV1,XNV1,1.D0)
            XNRT=XNRT1
            VAR=EXPOR*WIG6N*XNRT*XJ12
            VAR=VAR*EXPOM*WIGMJ*BETA
          ELSE
            VAR=ZERO
          ENDIF
          ZMAT(IGR,ISYM)=-VAR
C CORRECTION TERM         GLS                          -IGLS-
C    'VAR' WIRD UEBERNOMMEN AUS S.Z
            WIG9K=XNINEJ(XNV2,XNV1,TWO,XS,XS,ONE,XJV2,XJV1,ONE)
            WIG3N=THREEJ(XNV2,TWO,XNV1,-XL,ZERO,XL)
            WIG3K=THREEJ(ONE,TWO,ONE,ZERO,ZERO,ZERO)
            VARK=FIVE*WIG3N*WIG3K*WIG9K
            IF(DELTAN.LT.0.1) THEN
              WIG9K=XNINEJ(XNV2,XNV1,ZERO,XS,XS,ONE,XJV2,XJV1,ONE)
              WIG3N=EXPON/DSQRT(TWO*XNV1+ONE)
              WIG3K=-ONE/DSQRT(THREE)
              VARK=VARK+WIG9K*WIG3N*WIG3K
            ENDIF
            VARK=VARK*EXPON*XN12*XJ12*XSRT
            VARK=VARK*EXPOM*WIGMJ*BETA
            VAR=ZMAT(IGS,ISYM)+VARK
            ZMAT(IGLS,ISYM)=VAR
            IF(DABS(XL-ONE).LT.0.1D0)THEN
               IVORZ=IPAR*(-1)**NINT(XNV1)
C LAMBDA-DOUBLING TERM    gl`                         -IGLP-
               WIG9K=XNINEJ(XJV2,XJV1,ONE,XNV2,XNV1,TWO,XS,XS,ONE)
               WIG3N=EXPON*THREEJ(XNV2,TWO,XNV1,-XL,TWO,-XL)
               VARK=-EXPOM*WIGMJ*BETA*DSQRT(FIVE)
               VAR=VARK*XJ12*WIG9K*WIG3N*XN12*XSRT
               ZMAT(IGLP,ISYM)=IVORZ*VAR
C LAMBDA-DOUBLING TERM    gre`                        -IGRP-
               XNRT2=DSQRT(XNV2*(XNV2+ONE)*(TWO*XNV2+ONE))
               XX=SIXJ(XNV2,ONE,XNV2,ONE,XNV1,TWO)*XNRT2
               XX=XX + SIXJ(XNV2,ONE,XNV1,ONE,XNV1,TWO)*XNRT1
               VAR=HALF*XX*WIG3N*VARK*XN12
               EXPOJ=(-1)**NINT(XNV1+XS+XJV1)
               VAR=VAR*EXPOJ*SIXJ(XNV2,XJV2,XS,XJV1,XNV1,ONE)*XJ12
               ZMAT(IGRP,ISYM)=IVORZ*VAR
             ENDIF
C NUCLEAR SPIN ZEEMAN TERM    gI                      -IGI-
             IF(XI.LT.0.1D0) GOTO 101
             IF(DELTAJ.GT.0.1D0) GOTO 101
             IF(DELTAN.GT.0.1D0) GOTO 101
             BETAN=0.544617D-03*BETA
             VAR=-BETAN*XMIV1
             ZMAT(IGI,ISYM)=VAR
  101 CONTINUE
  100 CONTINUE
 
      DO 300 I1=1,ISUM
c       WRITE(2,*) ' ZEEDEC WW ',I1
c       DO 301 I2=1,JDIM
c        WRITE(2,302)(ZMAT(I1,(I2*(I2-1)/2+I3)),I3=1,I2)
c  302   FORMAT('0',6(D17.10,3X))
c  301  CONTINUE
  300 CONTINUE
 
      RETURN
      END
C
C---------------------------------------------------------------------
C---------------------------------------------------------------------
C
      SUBROUTINE SPCPLT
      IMPLICIT REAL*8 (A-H,Q-Z)
      CHARACTER*3 UNIT,DUMMY
      CHARACTER*4 UNITS
      CHARACTER*5 TITEL
      CHARACTER*256 TEXT(4)
      CHARACTER*60 TTEXT
      CHARACTER*1 CPOL
      CHARACTER*1 FPLOT

      INTEGER*4 LENGTH(4)
c      REAL*4 PLTX(15),PLTY(15),PLTYS(100),PLASER(6)
c PLTX,PLTY,PLTYS used in OXPLOT only
      real*8 plaser(6)
      REAL*8 PLTE(3,40,15)
      REAL XARR(2),YARR(2)
      DIMENSION E(15),EUNTEN(15),FCAL(15),BX(15),CONST(80)
ckdh const(110) changed to const(80), 29/11/94
      DIMENSION EOBEN(40,15),RHO(7),ATOM(2,7),XIA(7)
C
      COMMON/SIM/ISIM
      COMMON/CONS/CONST
      COMMON/MODE/IFLD,ISPEC,INTEN
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/EIG/E,FLXC
      COMMON/EINEIT/UNIT
      COMMON/FIELD/BX
      COMMON/TIT/TITEL,ttext
      COMMON/MODEP/ IMOD
      COMMON/MODEI/ IDECOP
      COMMON/MODPLT/IKOINZ,IOUT,IPLOT
      COMMON/ISOTO/ATOM,RHO,XIA,IBOC,NISO
      COMMON/ILAB/LABEL
      COMMON/CPCALC/INQUAD,ITERA,EPSB
      COMMON/PLOTDAT/PLTMIN,PLTMAX,BMIN,BMAX,NOFLD,PLASER,CPOL
      COMMON/PLOTVAL/PLTE
C
  249 READ(1,250) DUMMY
      IF(DUMMY.EQ.'END') GOTO 30
      IF(DUMMY.NE.'CP+') GOTO 249
      READ(1,*) INQUAD
      READ(1,*) ITERA
      READ(1,*) EPSB
  251 READ(1,250) DUMMY
      IF(DUMMY.EQ.'END') GOTO 30
      IF(DUMMY.NE.'CPL') GOTO 251
  250 FORMAT(A3)
      read(1,248) ttext
  248 format(A60)
      READ(1,*) IKOINZ
      READ(1,*) IOUT
      READ(1,*) IPLOT
      READ(1,*) IPRED
      READ(1,*) ISIM
C Next two lines control polarisation and UNIRAS output device.
C D. A. G. 8-7-92:
      READ(1,1093) CPOL
      READ(1,*) IUD
      read(1,*) FPLOT
 1093 FORMAT(A1)
c******************************************************************
c Prepare lmrin.dat:
c  (temperature, field limits, and other parameters must be
c   changed here or edited into lmrin.dat)
c******************************************************************
      if(isim.eq.1) then
        write(13,242) ttext
        write(14,241) ttext
  242 format(A60,'(sig pol)#')
  241 format(A60,' (pi pol)#')
        write(13,240) fplot
        write(14,240) fplot
  240 format('nu=',F9.4,'cm-1#')
        write(13,239)
        write(14,239)
  239 format('temperature=350K,mod=0#')
        write(13,238) fplot
        write(14,238) fplot
c Plot simulation with modulation "on" and set to a current of
c   1.2 (approximately the maximum, corresponding to a 
c   measured current of about 2.8). 
c Last 2 parameters are for plotting of multiple
c   spectra - not necessary if just one spectrum done.
  238 format(F9.4,' 40.0D0 350.0D0 1.2D0  0   0.001')
        write(13,237)
        write(14,237)
  237 format('1 0.0 15000.0 -1.0 1.0')
      endif
C
      IF(IKOINZ.EQ.1) WRITE(11,252)
  252 FORMAT('DATA ---------------------')
      CALL KOPF(3)
  206 READ(1,250) DUMMY
      IF(DUMMY.NE.'DAT') GOTO 206
      IF(DUMMY.EQ.'END') GOTO 30
      ICOUNT=0
C LIST THE QUANTUM NUMBERS,LASER FREQUENCY AND MAGNETIC FIELD
  101 READ(1,*)ISO,XL2,VAU2,XN2,XJ2,XHFS2,IPAR2,NFREQ,NEUPIC,BMIN,PLTMIN
      IF(VAU2.LT.0)GO TO 30
      IF(ISO.LT.0)GO TO 30
C TERMINATE WITH A NEGATIVE INPUT
      READ(1,*) XL1,VAU1,XN1,XJ1,XHFS1,IPAR1,NOFLD,IAUTO,BMAX,PLTMAX
C  INTRODUCE THE LASER FREQUENCY
      DO 205 I=1,NFREQ
       READ(1,*) PLASER(I)
  205 CONTINUE
C
C  FOR AUTOMATIC SCALING OF THE PLOTS
      IF(NEUPIC.EQ.1.AND.PLTMAX.LE.PLTMIN) IAUTO=1
      IF(NEUPIC.EQ.1) ICHECK=0
C
      ICOUNT=ICOUNT+1
      WRITE(*,*) ICOUNT
      DB=DSQRT(BMAX-BMIN)/(NOFLD-1)
      DO 203 I=1,NOFLD
      BX(I)=BMIN+((I-1)*DB)**2
  203 CONTINUE
      JD=XJ2-XJ1
      XJABS=DABS(XJ2)
C CALCULATION OF THE UPPER STATES
      XI=XIA(ISO)
      XL=XL2
      VAU=VAU2
      XN=XN2
      XJ=XJ2
        IF(LABEL.EQ.0) THEN
          XJVAL=XJ
        ELSE
          XJVAL=XN+XS+1.0D0-XJ
        ENDIF
      XHFS=XHFS2
      IPAR=IPAR2
      IF(XI.LT.0.1) THEN
        IF(IDECOP.EQ.0) THEN
          XHFS=0.0
        ELSE
          XHFS=XJVAL
        ENDIF
      ENDIF
C  CALCULATION OF THE NUMBER OF THE M-COMPONENT
      IF(IDECOP.EQ.0) THEN
        IMF=NINT(2.*XJVAL+1.)
        XM=XJVAL+1
      ELSE
        IMF=NINT(2*XHFS+1)
        XM=XHFS+1.
      ENDIF
      DO 204 IO=1,IMF
       XM=XM-1
       CALL MATREP
        IF(IDECOP.EQ.0) THEN
          CALL ZEEDEC
        ELSE
          CALL ZEEMAN
        ENDIF
      IF(XI.NE.0.0D0) THEN
        IF(IDECOP.EQ.0) THEN
          CALL HYPDEC
        ELSE
          CALL HYPERF
        ENDIF
      ENDIF
       IF(XL.EQ.1.D0.AND.IPAR.NE.0) CALL DOUBLE
       IF(XL.EQ.2.D0.AND.IPAR.NE.0) CALL DOUBDE
C      WRITE(2,555) XN,XJ,XM 
C 555  FORMAT('XN= ',F5.2,8X,'XJ= ',F5.2,8X,'XM= ',F5.2,'  Upper Level')
C       mjfind - above two expressions write upper level N, J and M values 
       CALL EIGNV(IEV,NOFLD)
       DO 202 I=1,NOFLD
        EOBEN(IO,I)=E(I)
C      WRITE(2,557) E(I),XJ,XM 
C 557  FORMAT('EOBEN = ',F18.13,'     XJ = ',F5.2,'     XM = ',F5.2) 
C       mjfind - above two expressions expanded to show J and M values 
C       the original expression is below
c       WRITE(2,*) 'EOBEN=',E(I)
  202  CONTINUE
  204 CONTINUE
C CALCULATION OF THE LOWER STATES
      VAU=VAU1
      XL=XL1
      XN=XN1
      XJ=XJ1
        IF(LABEL.EQ.0) THEN
          XJVAL=XJ
        ELSE
          XJVAL=XN+XS+1.0D0-XJ
        ENDIF
      XHFS=XHFS1
      IPAR=IPAR1
      IF(XI.LT.0.1) THEN
        IF(IDECOP.EQ.0) THEN
          XHFS=0.0
        ELSE
          XHFS=XJVAL
        ENDIF
      ENDIF
      IF(IDECOP.EQ.0) THEN
        IMF=NINT(2.*XJVAL+1.)
        XM=XJVAL+1
      ELSE
        IMF=NINT(2*XHFS+1)
        XM=XHFS+1
      ENDIF
      DO 211 IU=1,IMF
       XM=XM-1
       CALL MATREP
        IF(IDECOP.EQ.0) THEN
          CALL ZEEDEC
        ELSE
          CALL ZEEMAN
        ENDIF
       IF(XI.NE.0.0D0) THEN
         IF(IDECOP.EQ.0) THEN
           CALL HYPDEC
         ELSE
           CALL HYPERF
         ENDIF
       ENDIF
       IF(XL.EQ.1.0D0.AND.IPAR.NE.0) CALL DOUBLE
       IF(XL.EQ.2.0D0.AND.IPAR.NE.0) CALL DOUBDE
C      WRITE(2,556) XN,XJ,XM 
C 556  FORMAT('XN= ',F5.2,8X,'XJ= ',F5.2,8X,'XM= ',F5.2,'  Lower Level')
C      mjfind - above two expressions write N, J and M values 
       CALL EIGNV(IEV,NOFLD)
       DO 210 IB=1,NOFLD
        EUNTEN(IB)=E(IB)
C       WRITE(2,558) EUNTEN(IB),XJ,XM 
C 558  FORMAT('EUNTEN = ',F18.13,'     XJ = ',F5.2,'     XM = ',F5.2) 
C       mjfind - above two expressions expanded to show J and M values 
C       the original expression is below
c        WRITE(2,*) 'EUNTEN=',EUNTEN(IB)
C       SC May 1989
C       For a plot of the Mj components of the
C       J levels, then replace EUNTEN(IB)=E(IB), by
C       EUNTEN(IB)=0.0, then in the data set, set the
C       upper and lower levels as the same, and plot
C       using pi polarization (delta Mj=0).
  210  CONTINUE
C   CALCULATION OF THE TRANSITION FREQUENCY
C
       PLTE(1,IU,1)=0.0
       PLTE(2,IU,1)=0.0
       PLTE(3,IU,1)=0.0
       XJVAL=XJ2
       IF(LABEL.EQ.1) XJVAL=XN2+XS+1.0D0-XJ2
       IF(IDECOP.EQ.0) THEN
         IMFO=NINT(2.*XJVAL+1)
         XMO=XJVAL+1
       ELSE
         IMFO=NINT(2*XHFS2+1)
         XMO=XHFS2+1
       ENDIF
       DO 137 IO=1,IMFO
        XMO=XMO-1
        IF(IDECOP.EQ.0) THEN
          DELTAM=XMO+XHFS2-XM-XHFS1
        ELSE
          DELTAM=XMO-XM
        ENDIF
        IF(DABS(DELTAM).LT.1.1) THEN
        IPOS=NINT(DELTAM)+2
C	write(13,1111) IMFO,XJVAL,XMO,XM,XHFS1,XHFS2,DELTAM,IPOS
C1111	FORMAT(I3,2X,6(F10.6,2X),I3)
          DO 136 IB=1,NOFLD
           PLTE(IPOS,IU,IB)=EOBEN(IO,IB)-EUNTEN(IB)
c           write(13,1111)iu,ib,plte(ipos,iu,ib),eoben(io,ib),
c     &                     eunten(ib)
c1111      FORMAT(2(i3,2x),3(f15.10,2x))    
           IF(IAUTO.EQ.1) THEN
             IF(ICHECK.EQ.0) THEN
               PLTMAX=PLTE(IPOS,IU,IB)
               PLTMIN=PLTMAX
               ICHECK=1
             ELSE
               IF(PLTMAX.LT.PLTE(IPOS,IU,IB)) PLTMAX=PLTE(IPOS,IU,IB)
               IF(PLTMIN.GT.PLTE(IPOS,IU,IB)) PLTMIN=PLTE(IPOS,IU,IB)
             ENDIF
           ENDIF
  136     CONTINUE
        ENDIF
  137  CONTINUE
  211 CONTINUE
      IF(IOUT.NE.0) THEN
        WRITE(2,*) ' NEW ZERO FIELD TRANSITION'
        DO 220 I1=1,3,1
        IF(I1.NE.2) THEN
          WRITE(2,*) ' SIGMA-POLARISATION , DELTA Mj = +-1'
        ELSE
          WRITE(2,*) ' PI-POLARISATION , DELJA Mj = 0'
        ENDIF
         XJVAL=XJ1
         IF(LABEL.EQ.1) XJVAL=XN1+XS+1.0D0-XJ1
         IF(IDECOP.EQ.0) THEN
           XM1=XJVAL+1.
         ELSE
           XM1=XHFS1+1
         ENDIF
         DO 221 I2=1,IMF
          XM1=XM1-1
          IF(IDECOP.EQ.0) THEN
            XM2=XM1+XHFS1-XHFS2+I1-2
          ELSE
            XM2=XM1+I1-2
          ENDIF
          IF(ABS(PLTE(I1,I2,1)).GT.1.0E-9) THEN
            WRITE(2,331) VAU2,XN2,XJ2,XHFS2,XM2,IPAR2,ISO,
     &                   VAU1,XN1,XJ1,XHFS1,XM1,IPAR1
            WRITE(2,330) (BX(I),I=1,NOFLD)
            WRITE(2,330) (PLTE(I1,I2,I),I=1,NOFLD)
c(kdh) Put information for tuning diagram in unit 7 (perpendicular 
c polarization) and unit 8 (parallel polarization) - component is
c    traced forwards and backwards to suit xvgr plotting.
            if(iplot.eq.1) then
              do i=1,nofld
               if(i1.ne.2) then
                write(7,3301) bx(i),plte(i1,i2,i)
               else
                write(8,3301) bx(i),plte(i1,i2,i)
	       endif
 3301           format(2F10.3)
              enddo
              do i=1,nofld-1
               if(i1.ne.2) then
                write(7,3301) bx(nofld-i),plte(i1,i2,nofld-i)
               else
                write(8,3301) bx(nofld-i),plte(i1,i2,nofld-i)
               endif
              enddo
            endif
          ENDIF
  221    CONTINUE
  220   CONTINUE
  330   FORMAT(10(3X,F10.3))
  331   FORMAT(/' VAU2=',F5.1,' N2=',F5.1,' J2=',F5.1,' HF2=',F5.1,
     &          ' M2=',F5.1,' PAR2=',I2,' ISOTOPE NUMBER',I2/
     &          ' VAU1=',F5.1,' N1=',F5.1,' J1=',F5.1,' HF1=',F5.1,
     &          ' M1=',F5.1,' PAR1=',I2)
      ENDIF
C
C HERE THE PLOTS ARE MADE
C
c switch here by commenting between Bonn and Ox
c in Bonn:
c(kdh) commented out - see xvgr plotting above:
c      IF(IPLOT.EQ.1) THEN
c       in Bonn:
CBONN       CALL BONNPLOT(NEUPIC,IMF,NFREQ,IUD) 
c      in Oxford:
COXFORD
c      CALL OXPLOT(NEUPIC,IMF,NFREQ,IUD) 
c      ENDIF
c
C     ENDIF
C
      IF(IKOINZ.EQ.1) THEN
        CALL KOINZI(XL2,VAU2,XN2,XJ2,XHFS2,IPAR2,XL1,VAU1,XN1,XJ1,
     &              XHFS1,IPAR1,BX,PLTE,PLASER,NOFLD,NFREQ)
      ENDIF
      GOTO 101
   30 CONTINUE
      IF(IKOINZ.EQ.1) WRITE(11,*) '1  1. -1. -1. -1. -1. -1. -1  0.0'
      IF(IPRED.EQ.1) REWIND(11)
      IF(IPRED.EQ.1) CALL SPCALC(11)
 
c switch here by commenting between Bonn and Ox
c in Bonn:
CBONN       IF(IPLOT.EQ.1) CALL ENDPLT
c in Oxford :
COXFORD
C      IF(IPLOT.EQ.1) CALL GCLOSE
 
      RETURN
      END
 
c============================================================
c  This subroutine provides the plotoutput using uniras routines
      SUBROUTINE OXPLOT(NEUPIC,IMF,NFREQ,IUD)
      IMPLICIT REAL*8 (B-H,Q-Z)
      CHARACTER*3 UNIT,DUMMY
      CHARACTER*4 UNITS
      CHARACTER*5 TITEL
      CHARACTER*256 TEXT(4)
      CHARACTER*60 TTEXT
      CHARACTER*1 CPOL
      INTEGER*4 LENGTH(4)
      REAL*4 PLTX(15),PLTY(15),PLTYS(100)
c PLASER changed to real*8 - kdh 4/7/94
      real*8 PLASER(6)
      DIMENSION E(15),EUNTEN(15),FCAL(15),BX(15),CONST(80)
ckdh const(12) changed to const(80), 29/11/94
      REAL*8 EOBEN(40,15),PLTE(3,40,15),
     &RHO(20),ATOM(2,20),XIA(20)
C
      COMMON/CONS/CONST
      COMMON/EINEIT/UNIT
      COMMON/FIELD/BX
      COMMON/TIT/TITEL,ttext
      COMMON/PLOTDAT/PLTMIN,PLTMAX,BMIN,BMAX,NOFLD,PLASER,CPOL
      COMMON/PLOTVAL/PLTE

        IF(NEUPIC.EQ.1) THEN
C      WRITE(*,635)
C  635 FORMAT( ' ENTER 1 TO WRITE OUT ARRAYS ',/,' 2 FOR A PLOT AT THE
C     & USERAREA (OUCS)',/,' 3 FOR A PLOT ON A VT4010 ,',/,' 4 FOR A
C     & POSTSCRIPT FILE ',/,' 5 FOR A PLOT ON A SUN ',/,' 6 FOR A PLOT
C     & ON A VT41XX ')
      IF(IUD.EQ.1)THEN
       WRITE(*,*) '  Graphics arrays will be written out.'
       ELSEIF(IUD.EQ.2)THEN
       WRITE(*,*) '  Uniras hardcopy output to USERAREA is selected.'
       ELSEIF(IUD.EQ.3)THEN
       WRITE(*,*) '  Uniras output will be to the screen of a VT4010 te
     &rminal(IBM-PC).'
       ELSEIF(IUD.EQ.4)THEN
       WRITE(*,*) '  Uniras output will be to a POSTSCRIPT file.'
       ELSEIF(IUD.EQ.5)THEN
       WRITE(*,*) '  Uniras output will be to the screen of a SUN works
     &tation.'
       ELSEIF(IUD.EQ.6)THEN
       WRITE(*,*) '  Uniras output will be to the screen of a VT41XX te
     &rminal.'
      ENDIF
C      READ(1,*) JD
C      WRITE(2,6010) JD
C 6010 FORMAT( ' DELTA J=',I3)
C CALL UNIRAS ROUTINES
      IF(IUD.EQ.1) GOTO 1234
C       IF(IUD.EQ.2) CALL GROUTE ('sel PHPUAB;ex')
C       IF(IUD.EQ.3) CALL GROUTE ('sel vt4010;ex')
C       IF(IUD.EQ.4) CALL GROUTE ('sel hposta;ex')
C       IF(IUD.EQ.6) CALL GROUTE ('sel vt41XX;ex')
C        CALL GOPEN
C        IF(IUD.EQ.3) CALL GVPORT(25.,25.,150.,120.)
C        CALL GVPORT(30.,30.,200.,150.)
 1234 CONTINUE
          DO 230 IB=1,NOFLD
           PLTX(IB)=sngl(BX(IB))
  230     CONTINUE
          WRITE(2,*) ' MIN   MAX  ', PLTMIN,PLTMAX
      XMIN=BMIN
      XMAX=BMAX
      YMIN=PLTMIN
      YMAX=PLTMAX
      IF (IUD.EQ.1) GOTO 1235
C        CALL GLIMIT(XMIN,XMAX,YMIN,YMAX,0.,0.)
C        CALL GWBOX(4.,3.,0.)
C        CALL GSCALE
C SET UP AXIS TEXT AND TITLE
c      WRITE(*,665)
c  665 FORMAT ( ' ENTER TITLE ')
c      READ(*,565) TTEXT
c  565 FORMAT(A60)
c      ttext=' NCO v3 P(3.5)     on    P(11) 8-7   pi-Pol.'
      TEXT(1)='GAUSS'
      TEXT(2)='MAGNETIC FIELD'
      TEXT(3)='CM-1'
      TEXT(4)='WAVENUMBER'
      LENGTH(1)=5
      LENGTH(2)=14
      LENGTH(3)=4
      LENGTH(4)=10
      X=(XMIN+XMAX)/2
      Y=YMAX
C        CALL RTXHEI(3.0)
C        CALL RTXJUS(1,0)
C        CALL RTX(50,TTEXT,X,Y)
C        CALL RAXDIS(6,1,0)
C        CALL RAXLFO(5,0,1,1)
C        CALL RAXIS2(YMIN,XMIN,3.,LENGTH,TEXT)
 1235 CONTINUE
        ENDIF
c       LOOP OVER DELTA M VALUES FOR PLOT: I1=2 for Pi-Pol.
        IF(CPOL.EQ.'S')THEN
         I11=1
         I12=3
         I13=2
        ELSE
         I11=2
         I12=2
         I13=1
        ENDIF
         DO 231 I1=I11,I12,I13
         DO 231 I2=1,IMF
          IF(PLTE(I1,I2,1).NE.0.0) THEN
            DO 233 I=1,NOFLD
             PLTY(I)=sngl(PLTE(I1,I2,I))
             write(15,191) pltx(i),plty(i)
  233       CONTINUE
 191        format(f20.10,10x,f20.10)
C             CALL BINTSP(PLTX,PLTY,NOFLD,PLTYS,100,0.0)
C             CALL BLIVEC(PLTYS,100,0,0)
          ENDIF
         CONTINUE
  231   CONTINUE
C NEW CODE TO DRAW LASER LINE JPT 28.6.91.
        DO 310 I=1,NOFLD
          PLTY(I)=sngl(PLASER(1))
  310 CONTINUE
C        CALL BINTSP(PLTX,PLTY,NOFLD,PLTYS,100,11.0)
C        CALL BLIVEC(PLTYS,100,0,0)
        PLTO2=XO2
        PLTJ2=XJ2
        PLTO1=XO1
        PLTJ1=XJ1
        PYZWEI=(PLTY(1)-PLTMIN)/(PLTMAX-PLTMIN)

        RETURN
        END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C    KOINZI CALCULATES THE ZEEMAN COINCIDENCE OF A TRANSITION
C    WITH ONE OR MORE LASER LINES.
C
      SUBROUTINE KOINZI(XL2,VAU2,XN2,XJ2,XHFS2,IPAR2,XL1,VAU1,XN1,
     &                  XJ1,XHFS1,IPAR1,BX,PLTE,PLASER,NOFLD,NFREQ)
      IMPLICIT REAL*8 (A-H,Q-Z)
      IMPLICIT REAL*8 (P)
      DIMENSION BX(15),PLTE(3,40,15),PLASER(6)
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/MODEI/ IDECOP
      COMMON/ILAB/LABEL
 
      XJVAL=XJ1
      WRITE(2,*) 'koinzi called'
      IF(LABEL.EQ.1) XJVAL=XN1+XS+1.0D0-XJ1
      DO 10 IFREQ=1,NFREQ
       FLAS=PLASER(IFREQ)
       DO 11 IPOL=1,3,1
c**********************************************************************
c IPOL=1 --> M2=M1-1
c     =2 --> M2=M1
c     =3 --> M2=M1+1
c**********************************************************************
        IF(IDECOP.EQ.0) THEN
         IMFU=NINT(2*XJVAL+1)
         XM1=XJVAL+1
c**********************************************************************
c XM1=M_J'
c**********************************************************************
        ELSE
          IMFU=NINT(2*XHFS1+1)
          XM1=XHFS1+1
c**********************************************************************
c XM1=M_F'
c**********************************************************************
        ENDIF
        DO 12 IU=1,IMFU
         XM1=XM1-1.
         IF(PLTE(IPOL,IU,1).NE.0.0) THEN
           IDIF1=NINT(DSIGN(1.D0,(PLTE(IPOL,IU,1)-FLAS)))
           DO 13 IB=2,NOFLD
            IDIF2=NINT(DSIGN(1.D0,(PLTE(IPOL,IU,IB)-FLAS)))
            IDIF12=IDIF1*IDIF2
            IF(IDIF12.EQ.-1) THEN
c**********************************************************************
c If PLTE(IPOL,IU,IB-1) is greater/less than FLAS, but
c    PLTE(IPOL,IU,IB) is less/greater than FLAS, then the coincidence
c    is between BX(IB-1) and BX(IB)
c**********************************************************************
              IF(IDECOP.EQ.0) THEN
                XM2=XM1+XHFS1-XHFS2+IPOL-2
              ELSE
                XM2=XM1+IPOL-2
c**********************************************************************
c XM2=M_F"
c**********************************************************************
              ENDIF
              BPRED=BINTER(BX(IB-1),BX(IB),PLTE(IPOL,IU,IB-1),
     &                     PLTE(IPOL,IU,IB),FLAS)
C	write(13,1111) ipol,iu,ib, bx(ib-1),bx(ib),plte(ipol,iu,ib-1),
C     &                       plte(ipol,iu,ib),bpred
C1111	format(3(i3,2x),5(f15.10,2x))
c**********************************************************************
c BINTER gives the field at which the coincidence occurs, by linear
c   interpolation
c**********************************************************************
              WRITE(11,300) ISO,XL2,VAU2,XN2,XJ2,XHFS2,XM2,IPAR2,
     &                      PLASER(IFREQ)
              WRITE(11,301) XL1,VAU1,XN1,XJ1,XHFS1,XM1,IPAR1,BPRED
              WRITE(2,300) ISO,XL2,VAU2,XN2,XJ2,XHFS2,XM2,IPAR2,
     &                     PLASER(IFREQ)
              WRITE(2,301)  XL1,VAU1,XN1,XJ1,XHFS1,XM1,IPAR1,BPRED
            ENDIF
            IDIF1=IDIF2
   13      CONTINUE
         ENDIF
   12   CONTINUE                 
   11  CONTINUE
   10 CONTINUE
  300 FORMAT(1X,I2,6(F5.1,1X),I2,1X,F15.7)
  301 FORMAT(3X,6(F5.1,1X),I2,1X,F15.7,5X,'1.0')
      RETURN
      END
C
C---------------------------------------------------------
C
      DOUBLE PRECISION FUNCTION BINTER(B1,B2,P1,P2,FLAS)
      IMPLICIT REAL*8 (A-H,O-Z)
      BINTER=B1+(FLAS-P1)/(P2-P1)*(B2-B1)
      RETURN
      END
C
C ==============================================================================
      FUNCTION XNINEJ(J11,J12,J13,J21,J22,J23,J31,J32,J33)
C
C SUBROUTINE NUMBER 21.
C
C CALCULATES THE WIGNER 9-J SYMBOL
C
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 J11,J12,J13,J21,J22,J23,J31,J32,J33
C
      XKMIN=DMAX1(DABS(J11-J33),DABS(J12-J23),DABS(J21-J32))
      XKMAX=DMIN1(J11+J33,J21+J32,J12+J23)
C
C XKMAX AND XKMIN ARE THE MIN AND MAX ALLOWED VALUES OF XK
C
      KMAX=IDINT(XKMAX-XKMIN+0.5)+1
      IF(MOD(IDINT(2.0D0*XKMAX+0.5D0),2) .EQ. 1) GOTO 10
C XK IS INTEGRAL
      SIGN = 1.0D0
      GO TO 20
C XK IS HALF INTEGRAL
   10 SIGN = -1.0D0
   20 XNINEJ=0.0D0
      DO 1 J = 1,KMAX
      XK = XKMIN+J-1.
      XNINEJ=XNINEJ+SIGN*(2.D0*XK+1.)*SIXJ(J31,J11,J21,XK,J32,J33)
     1*SIXJ(J12,J22,J32,J21,XK,J23)*SIXJ(J13,J11,J12,XK,J23,J33)
    1 CONTINUE
      RETURN
      END
C
C---------------------------------------------------------------------
C
      FUNCTION ITRI(A,B,C)
      IMPLICIT REAL*8 (A-H,O-Z)
      IR=0
      AX=A+B
      AY=DABS(A-B)
      IF(C.LT.AY.OR.C.GT.AX) IR=1
      ITRI=IR
      RETURN
      END

      SUBROUTINE SPCFIT
C
C     SUBROUTINE FOR LSQRS FIT. READ NDATA TRANSITIONS, NFLOAT PARAMETER
C      BE DETERMINED MAX NO OF ITERATIONS ITRN
C
C     TO INCREASE THE NUMBER OF DATA POINTS INCREASE THE 1200 DIM
C     IN ALL THE ARRAYS IN /LSQ2/ AND ISOT, INTY, BTESLA
C     ALL DIM=31 ARRAYS AND WORKDI MAY BE LEFT AS THEY ARE
C     ALSO INCREASE OTHOA DIMS
C
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*3 UNIT,DUMMY
      CHARACTER*4 UNITS
      CHARACTER*1 ZWEIG,MARK
      DIMENSION Z(31,1200),Y(1200),WT(1200),CS(31),COF(31),TR(1200)
      DIMENSION UNCERT(1200),MFLAG(1200)
      DIMENSION P(80),CV(31,31),DP(1830),E(15),EIGVEC(60,60)
      DIMENSION WD(31,31),WORKDI(930)
      DIMENSION BX(15),EUNTEN(15),ISOT(1200),INTY(1200),BTESLA(1200)
      DIMENSION XIA(7),ATOM(2,7),RHO(7),YBG(1200)
      INTEGER PP(80)
c    &,DTYP(1200)
      REAL*8 L(60)
      COMMON/MODE/ IFLD,ISPEC,INTEN
      COMMON/MODEP/ IMOD
      COMMON/MODEI/ IDECOP
      COMMON/ISOTO/ATOM,RHO,XIA,IBOC,NISO
      COMMON/LTO/EIGVEC,L
      COMMON/EINEIT/UNIT
      COMMON/CONS/ P
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/FIELD/ BX
      COMMON/LSQ1/ STD, CHECK, NDATA, NFLOAT
      COMMON/LSQ2/ Z, Y, WT, CS, COF, CV
      COMMON/ZZZ/ DP
c      COMMON/ITYP/DTYP

      COMMON/EIG/ E, FLXC
      COMMON/DIM/JDIM
      COMMON/ILAB/LABEL
      DATA NCONS/80/
      DATA NDIMCV/31/
      DATA ZERO,HALF,ONE,TWO/0.0D0,0.5D0,1.0D0,2.0D0/
      DATA BLANK/99.0D0/
C
C     ALL 1200 DIMS MUST BE INCREASED FOR NDATA .GT.1200
C
      DIMENSION VAU1(1200),VAU2(1200),XN1(1200),XN2(1200),XJ1(1200),
     &      XJ2(1200),XHFS1(1200),XHFS2(1200),XM2(1200),XM1(1200),
     &      FLUX(1200),DLDP(31),YCALC(1200),IPAR1(1200),IPAR2(1200),
     &      FREQ(1200),WI(1200),YMHZ(1200),YB(1200),XL1(1200),
     &      XL2(1200)

      open (unit=4, file="table.dat")
C
   90 READ(1,'(A3)') DUMMY
      IF(DUMMY.NE.'CFI') GOTO 90
C
      READ(1,10) NDATA, NFLOAT, ITRN, TST, IWU
   10 FORMAT(3I4,F10.3,I4)
      IF(UNIT.EQ.'GHz') UNITS='GHz'
      IF(UNIT.NE.'GHz') UNITS='CM-1'
      TW=ZERO
      NZERO=0
      ITRK=1
      READ(1,11) (PP(I),I=1,NCONS)
   11 FORMAT(60I1)
C  CALCULATE THE NUMBER OF THE FIT PARAMETERS
      NFLOAT=0
      DO 789 I=1,NCONS
  789 NFLOAT=NFLOAT+PP(I)
      IF(IFLD.EQ.0)GO TO 700
      WRITE(2,13)
   13 FORMAT(////'   LEAST SQUARES FIT OF MAGNETIC RESONANCE DATA'/51X,
     1'***DATA LIST***'/' ISO  V2    N2    J2    HF2   M2 ',
     2'  P2  V1    N1    J1    HF1   M1   P1',8X,'FREQ',16X,
     3'FLUX',15X,'WT')        
cDTYP')
C
   91 READ(1,'(A3)') DUMMY
      IF(DUMMY.NE.'DAT') GOTO 91
C
      DO 20 I=1,NDATA
      READ(1,*)  ISOT(I),XL2(I),VAU2(I),XN2(I),XJ2(I),XHFS2(I),XM2(I),
     1IPAR2(I),FREQ(I)
      READ(1,*) XL1(I),VAU1(I),XN1(I),XJ1(I),XHFS1(I),XM1(I),
     1IPAR1(I),FLUX(I),WT(I)
c,DTYP(I)
C IF IWU.EQ.1, UNCERTAINTIES READ INTO WT(I), SO COPY AND CALCULATE WTS
      IF(IWU.EQ.1) THEN
	UNCERT(I)=WT(I)
   	IF(UNCERT(I).GT.ZERO) THEN
		WT(I)=UNCERT(I)**(-2)
	ENDIF
      ENDIF
      TW=TW+WT(I)
      IF(WT(I).EQ.ZERO) NZERO=NZERO+1
      WRITE(2,16) ISOT(I),VAU2(I),XN2(I),XJ2(I),XHFS2(I),XM2(I),
     &            IPAR2(I),
     &            VAU1(I),XN1(I),XJ1(I),XHFS1(I),XM1(I),IPAR1(I),
     &            FREQ(I),FLUX(I),UNCERT(I)
   20 CONTINUE
C  14 FORMAT(5F5.1,I5,2F20.10)
C  15 FORMAT(5F5.1,I5,2F20.10)
   16 FORMAT(' ',I2,5(1X,F5.1),1X,I2,5(1X,F5.1),1X,I2,3(2X,F17.7))
C     &             ,2X,F25.7)
      GO TO 800
  700 WRITE(2,131)
  131 FORMAT(' '////' ZERO FIELD LEAST SQUARES FIT '/51X,
     1'***DATA LIST***'/'     V2     N2     J2     HFS2   ',
     2'V1     N1     J1     HFS1         FREQ                  ',
     3'                  WT')      
cDTYP')
   92 READ(1,'(A3)') DUMMY
      IF (DUMMY.NE.'DAT') GOTO 92
      DO 801 I=1,NDATA
      READ(1,*) ISOT(I),XL2(I),VAU2(I),XN2(I),XJ2(I),XHFS2(I),IPAR2(I),
     &            FREQ(I)
      READ(1,*) XL1(I),VAU1(I),XN1(I),XJ1(I),XHFS1(I),IPAR1(I),
     &            FLUX(I),WT(I)
c,DTYP(I)
      WRITE(2,161) VAU2(I),XN2(I),XJ2(I),XHFS2(I),
     1VAU1(I),XN1(I),XJ1(I),XHFS1(I),FREQ(I),WT(I)
c,DTYP(I)
C 141 FORMAT(I3,4F5.1,I5,F20.10)
C 151 FORMAT(4F5.1,I5,F20.10)
  161 FORMAT(' ',8(2X,F5.1),3(2X,F20.10),2X,I1)
      XM1(I)=XHFS1(I)
      XM2(I)=XHFS2(I)
      FLUX(I)=ZERO
      TR(I)=ZERO
C IF IWU.EQ.1, UNCERTAINTIES READ INTO WT(I), SO COPY AND CALCULATE WTS
      IF(IWU.EQ.1) THEN
	UNCERT(I)=WT(I)
   	IF(UNCERT(I).GT.ZERO) THEN
		WT(I)=UNCERT(I)**(-2)
	ENDIF
      ENDIF
      TW=TW+WT(I)
      IF(WT(I).EQ.ZERO) NZERO=NZERO+1
  801 CONTINUE
  800 WRITE(2,1111) ndata,NZERO
 1111 format('NDATA=',I4,5X,'NZERO=',I4)
      DO 9 I=1,NCONS
      IF(PP(I).EQ.0) GO TO 9
      WRITE(2,22) I, P(I)
    9 CONTINUE
   22 FORMAT(/' LEAST SQUARES FIT TO PARAMETER ',I3,' INIT VALUE WAS '
     1,F15.8)
C     CALL TITLE(3)
  221 DO 35 I=1,NDATA
C
C  CALCULATE THE LOWER ENERGY LEVELS
C
C      DTYP=DTYP(I)
c       IF(DTYP(I).EQ.0) IDECOP=0
c       IF(DTYP(I).EQ.0) LABEL=1
c       IF(DTYP(I).EQ.1) IDECOP=1
c       IF(DTYP(I).EQ.1) LABEL=0
      ISO=ISOT(I)
      XI=XIA(ISO)
      VAU=VAU1(I)
      XL=XL1(I)
      XN=XN1(I)
      XJ=XJ1(I)
      XHFS=XHFS1(I)
       IF(XHFS.EQ.BLANK) XI=ZERO
      XM=XM1(I)
      IF(XI.LT.0.1) THEN
        IF(IDECOP.EQ.0) THEN
          XHFS=ZERO
        ELSE
          XHFS=XJ
        ENDIF
      ENDIF
      IPAR=IPAR1(I)
      BX(1)=FLUX(I)
      NOFLD=1
      CALL MATREP
      IF(IFLD.NE.0) THEN
        IF(IDECOP.EQ.0) THEN
          CALL ZEEDEC
        ELSE
          CALL ZEEMAN
        ENDIF
      ENDIF
      IF(XI.NE.ZERO) THEN
        IF(IDECOP.EQ.0) THEN
          CALL HYPDEC
        ELSE
          CALL HYPERF
        ENDIF
      ENDIF
      IF(XL.EQ.1.0.AND.IPAR.NE.0) CALL DOUBLE
      IF(XL.EQ.2.0.AND.IPAR.NE.0) CALL DOUBDE
      CALL EIGNV(IEV,NOFLD)
      EUNTEN(1)=E(1)
      IT=1
C
C CALCULATION OF THE ABLEITUNGSMATRIZEN
C
      DO 24 K=1,NCONS
      IF(PP(K).EQ.0) GO TO 24
      IF(IMOD.EQ.1) CALL DERIVH(K)
      IF(IMOD.EQ.0) CALL DERIV0(K)
      DLDP(IT)=-FABA(EIGVEC,JDIM,DP,IEV)
        WRITE(9,1010) I,IT,DLDP(IT)
 1010 FORMAT(' TRANSITION',I3,'  PARAMETER',I3,'LOWER DLDP=',F20.7)
      IT=IT+1
   24 CONTINUE
C
C     NOW CALCULATE UPPER STATE EVALUES AND DERIVATIVES
C
      VAU=VAU2(I)
      XL=XL2(I)
      XN=XN2(I)
      XJ=XJ2(I)
      XHFS=XHFS2(I)
      XM=XM2(I)
      IPAR=IPAR2(I)
      IF(XI.LT.0.1) THEN
        IF(IDECOP.EQ.0) THEN
          XHFS=ZERO
        ELSE
          XHFS=XJ
        ENDIF
      ENDIF
      CALL MATREP
      IF(IFLD.NE.0) THEN
        IF(IDECOP.EQ.0) THEN
          CALL ZEEDEC
        ELSE
          CALL ZEEMAN
        ENDIF
      ENDIF
      IF(XI.GT.ZERO) THEN
        IF(IDECOP.EQ.0) THEN
          CALL HYPDEC
        ELSE
          CALL HYPERF
        ENDIF
      ENDIF
      IF(XL.EQ.1.0.AND.IPAR.NE.0) CALL DOUBLE
      IF(XL.EQ.2.0.AND.IPAR.NE.0) CALL DOUBDE
      CALL EIGNV(IEV,NOFLD)
      F=E(1)-EUNTEN(1)
      IT=1
      DO 25 K=1,NCONS
      IF(PP(K).EQ.0) GO TO 25
c      write(8,*) k
      IF(IMOD.EQ.1) CALL DERIVH(K)
      IF(IMOD.EQ.0) CALL DERIV0(K)
      DLDP(IT)=DLDP(IT)+FABA(EIGVEC,JDIM,DP,IEV)
        WRITE(9,1000) I,IT,DLDP(IT)
 1000 FORMAT(' TRANSITION',I3,'  PARAMETER',I3,'UPPER DLDP=',F20.7)
      IT=IT+1
   25 CONTINUE
      F=E(1)-EUNTEN(1)
c      WRITE(2,*) 'spfit(intermediate): EUNTEN(1) = ',EUNTEN(1)
c      WRITE(2,*) 'spfit(intermediate): E(1) = ',E(1)
      Y(I)=FREQ(I)-F
      IF(ITRK.EQ.1)  YCALC(I)=Y(I)
      DO 26 K=1,NFLOAT
   26 Z(K,I)=DLDP (K)
   35 CONTINUE
      SDO=ZERO
      DO 36 I=1,NDATA
   36 SDO=SDO+Y(I)*Y(I)*WT(I)
      DN=(NDATA-NZERO-NFLOAT)
      IF((NDATA-NZERO).EQ.NFLOAT) DN=1.0
      SDO=DSQRT(SDO/DN)
      CALL ORTHOA
      IF(CHECK.GT.ZERO) GO TO 37
      WRITE(2,27)
   27 FORMAT(/////'   SUBROUTINE ORTHOA DETECTS SINGULAR MATRIX'////)
      DO 28 I=1,NDATA
      WRITE(2,29)  (Z(K,I),K=1,NFLOAT)
   28 CONTINUE
   29 FORMAT(/' ',10(F10.3,2X))
      GO TO 500
   37 STD=STD*DSQRT((NDATA-NFLOAT)/DN)
      WRITE(2,30)SDO,STD
   30 FORMAT(/'  ***OLD STD DEV = ',D15.8,'     ',' LINEAR EST. OF NEW
     & STD DEV = ',D15.8,'***')
      IF(SDO-STD.LT.TST*SDO) GO TO 50
      IF(ITRK.EQ.ITRN) GO TO 50
      WRITE(2,31)ITRK
   31 FORMAT(/'  INTERMEDIATE PARAMETER VALUES CYCLE ',I2)
      ITRK=ITRK+1
      IT=1
      DO 39 I=1,NCONS
      IF(PP(I).EQ.0) GO TO 39
      P(I)=P(I)+COF(IT)
      WRITE(2,381) I,P(I)
      IT=IT+1
   39 CONTINUE
  381 FORMAT(1X,'PARAMETER(',I2,') =',D15.8,' UNIT (WHERE APPROPRIATE)'
     &)
      GO TO 221
   50 IT=1
      STAN=DSQRT((NDATA-NZER0)/TW)*STD
      WRITE(2,387) STAN,UNITS
  387 FORMAT(/'   ESTIMATE OF STD DEVN OF A TYPICAL (SIC) OBSERVATION
     1',D15.8,4X,A4)
      WRITE(2,391)
  391 FORMAT(/////'         FINAL VALUES OF VARIED PARAMETERS'/)
      DO 52 I=1,NCONS
      IF(PP(I).EQ.0) GO TO 52
      P(I)=P(I)+COF(IT)
      WRITE(2,501) I,P(I),CS(IT)
      IT=IT+1
   52 CONTINUE
  501 FORMAT('  PARAMETER(',I2,')=',D16.9,' UNIT','  STD DEV IS ',
     1D15.8)
C
C     OUTPUT CORRELATION MATRIX
C
      WRITE(2,541)
  541 FORMAT(///////41X,'***CORRELATION MATRIX***')
      DO 54 I=1,NFLOAT
      WRITE(2,551) (CV(I,K),K=1,I)
   54 CONTINUE
  551 FORMAT(/' ',10(F10.6,3X))
C
C  CALCULATE THE CORRELATION
C
      NFL=NFLOAT
C          CALL DLINRG(NFL,CV,NDIMCV,WD,31)
C     CALL LINV1F(CV,NFL,NDIMCV,WD,31,WORKDI,IER)
C      CALL F01AAF(CV,31,NFL,WD,31,WORKDI,IER)
      CALL MINV(CV,WD,NFL,31,1)
      WRITE(2,5000)
5000  FORMAT(/////' CORRELATION (KAPPA) OF THE INDIVIDUAL PARAMETERS'/)
      DO 70 IFLT=1,NFLOAT
      WRITE(2,*) IFLT,'   ',WD(IFLT,IFLT)
   70 CONTINUE
C
C       FINAL CALCULATION
C
      WRITE(2,561)
  561 FORMAT(////'***FINAL ANALYSIS OF DATA WITH BEST FIT PARAMETERS***'
     1)
      ITUNE=0
      DO 55 I=1,NDATA
C     IF(IFLD.EQ.0) THEN
        NOFLD=1
        BX(1)=FLUX(I)
C     ELSE
C       NOFLD=3
C       BX(1)=FLUX(I)-10.
C       BX(2)=FLUX(I)
C       BX(3)=FLUX(I)+10.
C     ENDIF
C
C  CALCULATE THE LOWER STATES
C
C      DTYP=DTYP(I) 
c       IF(DTYP(I).EQ.0) IDECOP=0
c       IF(DTYP(I).EQ.0) LABEL=1
c       IF(DTYP(I).EQ.1) IDECOP=1
c       IF(DTYP(I).EQ.1) LABEL=0
      ISO=ISOT(I)
      XI=XIA(ISO)
      XL=XL1(I)
      VAU=VAU1(I)
      XN=XN1(I)
      XJ=XJ1(I)
      XHFS=XHFS1(I)
       IF(XHFS.EQ.BLANK) XI=ZERO
      XM=XM1(I)
      IPAR=IPAR1(I)
      IF(XI.LT.0.1) THEN
        IF(IDECOP.EQ.0) THEN
          XHFS=ZERO
        ELSE
          XHFS=XJ
        ENDIF
      ENDIF
      CALL MATREP
      IF(IFLD.NE.0) THEN
        IF(IDECOP.EQ.0) THEN
          CALL ZEEDEC
        ELSE
          CALL ZEEMAN
        ENDIF
      ENDIF
      IF(XI.NE.ZERO) THEN
        IF(IDECOP.EQ.0) THEN
          CALL HYPDEC
        ELSE
          CALL HYPERF
        ENDIF
      ENDIF
      IF(XL.EQ.1.0.AND.IPAR.NE.0) CALL DOUBLE
      IF(XL.EQ.2.0.AND.IPAR.NE.0) CALL DOUBDE
      CALL EIGNV(IEV,NOFLD)
        IF(IFLD.EQ.1) CALL EDERIV(IEV,DEDB1)
      DO 80 NF=1,NOFLD
       EUNTEN(NF)=E(NF)
c       WRITE(2,*) 'spfit(final): EUNTEN(NF)=',eunten(nf)
   80 CONTINUE
      IF(IDECOP.EQ.0) THEN
        XMF=XM+XHFS
      ELSE
        XMF=XM
      ENDIF
      IF(INTEN.EQ.1) CALL STOR(IEV,XMF,IPAR)
C
C   CALCULATE THE UPPER STATES
C
      VAU=VAU2(I)
      XL=XL2(I)
      XN=XN2(I)
      XJ=XJ2(I)
      XHFS=XHFS2(I)
      XM=XM2(I)
      IPAR=IPAR2(I)
      IF(XI.LT.0.1) THEN
        IF(IDECOP.EQ.0) THEN
          XHFS=ZERO
        ELSE
          XHFS=XJ
        ENDIF
      ENDIF
      CALL MATREP
      IF(IFLD.NE.0) THEN
        IF(IDECOP.EQ.0) THEN
          CALL ZEEDEC
        ELSE
          CALL ZEEMAN
        ENDIF
      ENDIF
      IF(XI.GT.ZERO) THEN
        IF(IDECOP.EQ.0) THEN
          CALL HYPDEC
        ELSE
          CALL HYPERF
        ENDIF
      ENDIF
      IF(XL.EQ.1.0.AND.IPAR.NE.0) CALL DOUBLE
      IF(XL.EQ.2.0.AND.IPAR.NE.0) CALL DOUBDE
      CALL EIGNV(IEV,NOFLD)
        IF(IFLD.EQ.1) CALL EDERIV(IEV,DEDB2)
      IF(INTEN.EQ.1) THEN
        IF(IDECOP.EQ.0) THEN
          CALL TRADEC(IEV,IFLD,WI(I))
        ELSE
          CALL TRANS(IEV,IFLD,WI(I))
        ENDIF
      ENDIF
c       WRITE(2,*) 'spfit(final): E(1)=', e(1)
      IF(IFLD.EQ.0) THEN
        Y(I)=FREQ(I)-E(1)+EUNTEN(1)
      ELSE
C       F1=E(1)-EUNTEN(1)
C       F2=E(3)-EUNTEN(3)
        IF(UNIT.NE.'GHz') TR(I)=(DEDB2-DEDB1)*29979.2458D0
        IF(UNIT.EQ.'GHz') TR(I)=(DEDB2-DEDB1)*1000.D0
        Y(I)=FREQ(I)-E(1)+EUNTEN(1)
        INTY(I)=NINT(Y(I)*1.0D3)
        YMHZ(I)=Y(I)*1.0D3
        BTESLA(I)=FLUX(I)*1.D-4
        YB(I)=YMHZ(I)/TR(I)
        YBG(I)=YMHZ(I)*29.9792458/TR(I)
      ENDIF
      MFLAG(I)=0
      IF(IWU.EQ.1.AND.UNCERT(I).NE.ZERO) THEN
	IF(DABS(Y(I)).GE.3.0D0*UNCERT(I)) MFLAG(I)=1
      ENDIF
   55 CONTINUE
      WRITE(2,61)UNITS,UNITS,UNITS
   61 FORMAT(/'          ***STATE QUANTUM NUMBERS***',26X,'OBS. FIELD
     1 ',2X,' OBS. FREQ ',4X,' O-C FREQ ',5X,' O-C  INIT',1X,'T. RAT
     2E'/9X,' POSTSCRIPT  1=LOWER   2=UPPER',25X,'(GAUSS)',8X,A4,
     311X,A4,9X,A4,6X,'(MHZ/G)')
      DO 62 I=1,NDATA
c converts o-c from cm-1 to GHz:
c      y(i)=y(i)*(299792458.0d0/1.0d7) 
      
      IF(IWU.EQ.0) THEN
      WRITE(2,64) VAU2(I),XN2(I),XJ2(I),XHFS2(I),XM2(I),IPAR2(I),
     &            ISOT(I),WT(I)
      ELSE
      WRITE(2,72) VAU2(I),XN2(I),XJ2(I),XHFS2(I),XM2(I),IPAR2(I),
     &            ISOT(I),UNCERT(I)
      ENDIF
      WRITE(2,63) VAU1(I),XN1(I),XJ1(I),XHFS1(I),XM1(I),IPAR1(I),
C     &            FLUX(I),FREQ(I),Y(I),YCALC(I),TR(I),TPROP(I)
     &            FLUX(I),FREQ(I),Y(I),YCALC(I),TR(I)
c,DTYP(I)
C mjfind - DTYP statements were commented out prior to modifying 
C by MJ - lowercase "c" is used as the comment character.
	IF(MFLAG(I).EQ.1) WRITE(2,660)
  660 FORMAT( '**** THE RESIDUAL FOR THIS POINT IS 3 TIMES GREATER
     & THAN ITS UNCERTAINTY')
      IF(INTEN.EQ.1) WRITE(2,71) WI(I) 
C      WRITE(2,968) y(i)
      fout=freq(i)
      if(wt(i).eq.0.0d0) fout=freq(i)-y(i)
      write(7,631) xn2(i),xj2(i),xhfs2(i),xn1(i),xj1(i),xhfs1(i),
     &             fout,y(i)
  631 format(6F5.1,2F14.5)
      I2M2=NINT(2*XM2(I))
      I2M1=NINT(2*XM1(I))
      I2HFS2=NINT(2*XHFS2(I))
      I2HFS1=NINT(2*XHFS1(I))
      IVAU2I=DABS(VAU2(I))
      IVAU1I=DABS(VAU1(I))
      IXN1I=DABS(XN1(I))
      IXN2I=DABS(XN2(I))
      IV2 = NINT(VAU2(I))
      IV1 = NINT(VAU1(I))
      IXN1 = NINT(XN1(I))
      IXN2 = NINT(XN2(I))
      IHFS2 = NINT(XHFS2(I))
      IHFS1 = NINT(XHFS1(I))
      IXJ1 = NINT(XJ1(I))
      IXJ2 = NINT(XJ2(I))

      write(4,670) IV2,IXN2,IXJ2,IHFS2,XM2(I),IPAR2(I),IV1,IXN1,IXJ2,
     &IHFS1,XM1(I),IPAR1(I),FREQ(I),FLUX(I),Y(I),UNCERT(I),TR(I)
 670  FORMAT(4I4,F5.1,5I4,F5.1,I4,F12.5,F10.2,F9.5,F10.6,F8.4)
 
cc        IF(XJ1(I)-XJ2(I).EQ.-1.D0) ZWEIG='R'
cc        IF(XJ1(I)-XJ2(I).EQ.0.D0) ZWEIG='Q'
cc        IF(XJ1(I)-XJ2(I).EQ.+1.D0) ZWEIG='P'
          I2J1=NINT(2*XJ1(I))
cc      IF(I.EQ.1) THEN
cc        WRITE(2,67)
cc       WRITE(2,68) FREQ(I),IVAU2I,IXN2I,IVAU1I,IXN1I
cc        WRITE(2,65) ZWEIG,I2J1,I2M2,I2M1,ISOT(I),BTESLA(I),YMHZ(I),
cc     $              YBG(I),TR(I)
cc      ELSE
cc        IF(XN1(I).NE.XN1(I-1).OR.XN2(I).NE.XN2(I-1)
cc     &     .OR.VAU2(I).NE.VAU2(I-1).OR.VAU1(I).NE.VAU1(I-1)
cc     &     .OR.FREQ(I).NE.FREQ(I-1)) THEN
cc          WRITE(2,68) FREQ(I),IVAU2I,IXN2I,IVAU1I,IXN1I
cc        WRITE(2,65) ZWEIG,I2J1,I2M2,I2M1,ISOT(I),BTESLA(I),YMHZ(I),
cc     $              YBG(I),TR(I)
cc        ELSE
cc            IF(XJ1(I).NE.XJ1(I-1).OR.XJ2(I).NE.XJ2(I-1)) THEN
cc            WRITE(2,65) ZWEIG,I2J1,I2M2,I2M1,ISOT(I),BTESLA(I),YMHZ(I),
cc     $                  YBG(I),TR(I)
cc            ELSE
cc         WRITE(2,651) I2M2,I2M1,ISOT(I),BTESLA(I),YMHZ(I),YBG(I),TR(I)
cc            ENDIF
cc        ENDIF
cc      ENDIF
      WRITE(20,*) Y(I)
   62 CONTINUE
   63 FORMAT(3X,'V1=',F5.1,' N1=',F5.1,' J1=',F5.1,' HF2=',F5.1,' M1=',
     & F5.1,' PAR1=',I2,4X,F10.2,3X,F12.5,3X,F12.6,3X,F12.6,5X,F8.4,
     &  3X,I1)
   64 FORMAT(1X/3X,'V2=',F5.1,' N2=',F5.1,' J2=',F5.1,' HF2=',F5.1,
     &' M2=',F5.1,' PAR2=',I2, ' ISOTOPE NUMBER',I2,10X,'WT=',F12.8)
   72 FORMAT(1X/3X,'V2=',F5.1,' N2=',F5.1,' J2=',F5.1,' HF2=',F5.1,
     &' M2=',F5.1,' PAR2=',I2, ' ISOTOPE NUMBER',I2,10X,'UNCERT=',F12.8)
   71 FORMAT(16X,' E-DIPOLE INTENSITY ( POPULATION FACTOR NOT INCL. ) ',
     & D12.5)
 968  format(' ','wavn=',f20.6)
   65 FORMAT(5X,A1,'(',I2,'/2)',1X,I3,'/2,',I3,'/2',4X,I1,4X,F7.5,
     #       2X,F8.1,3X,F7.1,4X,F5.2)
  651 FORMAT(13X,I3,'/2,',I3,'/2',4X,I1,4X,F7.5,
     #       2X,F8.1,3X,F7.1,4X,F5.2)
   66 FORMAT(/3X,'V2=',F5.1,' N2=',F5.1,' J2=',F5.1,' F2=',F5.1,
     &' MF2=',F5.1,' PAR2=',I2)
   67 FORMAT(8X,'J',6X,'MJ''',3X,'MJ"',2X,'ISOTOP',2X,
     #'FIELD',5X,'OBS-CALC',2X,'OBS-CALC',3X,'TR'/
     &       33X,'(TESLA)',4X,'(10-3CM)',2X,'(GAUSS)',4X,'(MHZ/G)')
   68 FORMAT(/2X,F10.5,4X,'V =',I1,2X,'N =',I1,2X,'<--',2X,
     &                'V"=',I1,2X,'N"=',I1/)
CV        IF(XJ1(I)-XJ2(I).EQ.-4.D0) ZWEIG='U'
CV        IF(XJ1(I)-XJ2(I).EQ.-3.D0) ZWEIG='T'
CV        IF(XJ1(I)-XJ2(I).EQ.-2.D0) ZWEIG='S'
CV        IF(XJ1(I)-XJ2(I).EQ.-1.D0) ZWEIG='R'
CV        IF(XJ1(I)-XJ2(I).EQ.0.D0) ZWEIG='Q'
CV        IF(XJ1(I)-XJ2(I).EQ.+1.D0) ZWEIG='P'
CV        IF(XJ1(I)-XJ2(I).EQ.+2.D0) ZWEIG='O'
CV        IF(XJ1(I)-XJ2(I).EQ.+3.D0) ZWEIG='N'
CV        IF(XJ1(I)-XJ2(I).EQ.+4.D0) ZWEIG='M'
CV        I2J1=NINT(2*XJ1(I))
CV    IF(I.EQ.1) THEN
C       WRITE(2,67)
C       IF(XJ1(I)-XJ2(I).EQ.-1.D0) ZWEIG='R'
C       IF(XJ1(I)-XJ2(I).EQ.0.D0) ZWEIG='Q'
C       IF(XJ1(I)-XJ2(I).EQ.+1.D0) ZWEIG='P'
C       ISJ1=NINT(2*XJ1(I))
CV      WRITE(2,68) ZWEIG,I2J1,FREQ(I)
CV    ELSE
C
C U,T,N and M are used to label the different delta J
C combinations and are derived by expanding the O,P,Q,R
C and S notation
C
CV      IF(XJ1(I).NE.XJ1(I-1).OR.XJ2(I).NE.XJ2(I-1)
CV   &     .OR.FREQ(I).NE.FREQ(I-1)) THEN
CV       WRITE(2,68) ZWEIG,I2J1,FREQ(I)
CV      ENDIF
CV    ENDIF
CV    IF(WT(I).LT.1.1) MARK=' '
CV    IF(WT(I).GT.1.1) MARK='*'
CV    IF(WT(I).EQ.0.0) MARK='$'
CV    I2M2=NINT(2*XM2(I))
CV    I2M1=NINT(2*XM1(I))
CV    I2HFS2=NINT(2*XHFS2(I))
CV    I2HFS1=NINT(2*XHFS1(I))
CV    WRITE(2,65) I2M2,I2HFS2,I2M1,I2HFS1,
CV   &  BTESLA(I),MARK,YMHZ(I),TR(I),YB(I),WI(I)
CV 62 CONTINUE
CV 63 FORMAT(3X,'V1=',F4.1,' N1=',F4.1,' J1=',F4.1,' HF2=',F4.1,' M1=',
CV   & F4.1,' PAR1=',I2,18X,F10.2,1X,F10.5,1X,F10.6,1X,F10.6,1X,F8.4,
CV   & F8.3)
CV 64 FORMAT(1X/3X,'V2=',F4.1,' N2=',F4.1,' J2=',F4.1,' HF2=',F4.1,
CV   &' M2=',F4.1,' PAR2=',I2, ' ISOTOPE NUMBER',I2)
CV 65 FORMAT(4X,'|',I2,'/2,',I2,'/2> |',
CV   & I2,'/2,',I2,'/2>',6X,F8.5,A1,2X,F6.1,2X,F7.2,
CV   7 2X,F7.2,1X,F7.3)
CV 66 FORMAT(/3X,'V2=',F5.1,' N2=',F5.1,' J2=',F5.1,' F2=',F5.1,
CV   &' MF2=',F5.1,' PAR2=',I2)
CV 67 FORMAT(6X,'MJ''',9X,'MJ"',13X,'FIELD',7X,'O-C'
CV   &       ,7X,'TR     O-C     INTEN'/
CV   &       34X,'(TESLA)    (MHZ)     (MHZ/G)  (G)')
CV 68 FORMAT(3X,A1,'(',I2,'/2)',4X,F10.5)
      WRITE(2,69)
   69 FORMAT(/'  * INDICATES LAMB-DIP OBSERVED'/
     &        '  $ INDICATES SIGNAL-OVERLAP, ZERO-WEIGHT'/)
      RETURN
  500 WRITE(2,5001)
 5001 FORMAT(////' ***ERROR : EXAMINE THE GIVEN DATA***'/////)
      STOP
      END
C
C---------------------------------------------------------------------
C
      SUBROUTINE DERIVH(JPARAM)
C
C     LOADS DERIVATIVES OF H WRT P(JPARAM) IN ROW ORDER INTO VECTOR DP
C
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION DP(1830),BX(15),RHO(7),DDMAT(3,1830),ATOM(2,7),XIA(7)
      DIMENSION QMAT(9,1830),DMAT(6,1830),HMAT(4,1830),ZMAT(7,1830)
      DIMENSION P(80)
      COMMON/MODE/ IFLD,ISPEC,INTEN
      COMMON/CONS/P
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/DIM/JDIM
      COMMON/ZZZ/DP
      COMMON/QMATS/QMAT
      COMMON/ZMATS/ZMAT
      COMMON/HMATS/HMAT
      COMMON/DMATS/DMAT
      COMMON/DDMATS/DDMAT
      COMMON/FIELD/BX
      COMMON/ISOTO/ATOM,RHO,XIA,IBOC,NISO
      KMAX=JDIM*(JDIM+1)
      KMAX=KMAX/2
      DO 100 K=1,KMAX
      DP(K)=0.0D0
  100 CONTINUE
      IF(JPARAM.LT.13) THEN
        IF(MOD(JPARAM,2).EQ.1) THEN
          BOC=1.+ATOM(1,ISO)*P(JPARAM+40)+ATOM(2,ISO)*P(JPARAM+41)
        ELSE
          BOC=1.
        ENDIF
      ENDIF
      WURHO=DSQRT(RHO(ISO))
C RUNNING ADDRESS  1 VIBRATIONAL CONSTANT
C   		   2 FINE STRUCTURE CONSTANT
C                  3 LAMBDA-DOUBLING CONSTANT IN PI STATE
C                  4 LAMBDA-DOUBLING CONSTANT IN DELTA STATES
C                  5 HYPERFINE PARAMETER
C                  6 ZEMMAN G-FACTOR
C                  7 BORN-OPPENHEIMER CORRECTION TERM
C                  8 FINE STRUCTURE EXTENSION
C                  9 DUMMY
      GOTO(1,1,1,1,
     &     2,2,2,2,2,2,2,2,2,2,2,2,
     &     3,3,3,3,
     &     4,4,4,4,
     &     5,5,5,5,5,5,5,5,
     &     6,6,6,6,6,6,6,6,
     &     7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
     &     9,9,9,9,9,9,9,9,9,9,9,9,9,9,
     &     8,8,8,8,8,8)JPARAM
C
    1 CONTINUE
      GOTO(11,12,13,14),JPARAM
C     DERIV WRT PARAMETER 1  WE
C
   11 DO 101 K=1,JDIM
      KK=K*(K-1)/2+K
      DP(KK)=(VAU+0.5)*WURHO*BOC
  101 CONTINUE
      GO TO 30
C
C     DERIV WRT PARAMETER 2  WEXE
   12 DO 102 K=1,JDIM
      KK=K*(K-1)/2+K
      DP(KK)=-((VAU+0.5)*WURHO)**2
  102 CONTINUE
      GO TO 30
C
C     DERIV WRT PARAMETER 3  WEYE
   13 DO 103 K=1,JDIM
      KK=K*(K-1)/2+K
      DP(KK)=((VAU+0.5)*WURHO)**3
  103 CONTINUE
      GO TO 30
C
C     DERIV WRT PARAMETER 4  WEZE
   14 DO 104 K=1,JDIM
      KK=K*(K-1)/2+K
      DP(KK)=((VAU+0.5)*WURHO)**4
  104 CONTINUE
      GO TO 30
C
C ROTATION AND FINE STRUCTURE
C
C
    2 CONTINUE
      IF(MOD(JPARAM,2).EQ.1) THEN
        IPOS=(JPARAM-3)/2
        DO 120 K1=1,JDIM
         DO 120 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=QMAT(IPOS,KLAUF)*BOC
          IF(IPOS.EQ.1) DP(KLAUF)=DP(KLAUF)*RHO(ISO)
          IF(IPOS.EQ.3) DP(KLAUF)=DP(KLAUF)*RHO(ISO)
          IF(IPOS.EQ.2) DP(KLAUF)=DP(KLAUF)*RHO(ISO)**2
  120   CONTINUE
      ELSE
        IPOS=(JPARAM-4)/2
        DO 121 K1=1,JDIM
         DO 121 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=-QMAT(IPOS,KLAUF)*(VAU+0.5)*WURHO
          IF(IPOS.EQ.1) DP(KLAUF)=DP(KLAUF)*RHO(ISO)
          IF(IPOS.EQ.3) DP(KLAUF)=DP(KLAUF)*RHO(ISO)
          IF(IPOS.EQ.2) DP(KLAUF)=DP(KLAUF)*RHO(ISO)**2
  121   CONTINUE
      ENDIF
      GOTO 30
    8 CONTINUE
      IF(MOD(JPARAM,2).EQ.1) THEN
        IPOS=(JPARAM-67)/2
        DO 180 K1=1,JDIM
         DO 180 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=QMAT(IPOS,KLAUF)*BOC
          IF(IPOS.EQ.7) DP(KLAUF)=DP(KLAUF)*RHO(ISO)**2
          IF(IPOS.EQ.8) DP(KLAUF)=DP(KLAUF)*RHO(ISO)
          IF(IPOS.EQ.9) DP(KLAUF)=DP(KLAUF)*RHO(ISO)**3
  180   CONTINUE
      ELSE
        IPOS=(JPARAM-68)/2
        DO 181 K1=1,JDIM
         DO 181 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=-QMAT(IPOS,KLAUF)*(VAU+0.5)*WURHO
          IF(IPOS.EQ.7) DP(KLAUF)=DP(KLAUF)*RHO(ISO)**2
          IF(IPOS.EQ.8) DP(KLAUF)=DP(KLAUF)*RHO(ISO)
          IF(IPOS.EQ.9) DP(KLAUF)=DP(KLAUF)*RHO(ISO)**3
  181   CONTINUE
      ENDIF
      GOTO 30
C
C LAMBDA-DOUBLING
C
C
    3 CONTINUE
      IF(MOD(JPARAM,2).EQ.1) THEN
        IPOS=(JPARAM-13)/2
        DO 130 K1=1,JDIM
         DO 130 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=DMAT(IPOS,KLAUF)*IABS(IPAR)
          DP(KLAUF)=DP(KLAUF)**(IPOS-1)
  130   CONTINUE
      ELSE
        IPOS=(JPARAM-14)/2
        DO 131 K1=1,JDIM
         DO 131 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=-DMAT(IPOS,KLAUF)*(VAU+0.5)*IABS(IPAR)*WURHO
          DP(KLAUF)=DP(KLAUF)**(IPOS-1)
  131   CONTINUE
      ENDIF
      GOTO 30
C
C LAMBDA-DOUBLING IN DELTA-STATES
C
C
    4 CONTINUE
      IF(MOD(JPARAM,2).EQ.1) THEN
        IPOS=(JPARAM-19)/2
        DO 140 K1=1,JDIM
         DO 140 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=DDMAT(IPOS,KLAUF)*IABS(IPAR)
          DP(KLAUF)=DP(KLAUF)*RHO(ISO)**(5-IPOS)
  140   CONTINUE
      ELSE
        IPOS=(JPARAM-20)/2
        DO 141 K1=1,JDIM
         DO 141 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=-DDMAT(IPOS,KLAUF)*(VAU+0.5)*IABS(IPAR)*WURHO
          DP(KLAUF)=DP(KLAUF)*RHO(ISO)**(5-IPOS)
  141   CONTINUE
      ENDIF
      GOTO 30
C
C HYPERFINE STRUCTURE
C
C
    5 CONTINUE
      IF(MOD(JPARAM,2).EQ.1) THEN
        IPOS=(JPARAM-23)/2
        DO 150 K1=1,JDIM
         DO 150 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=HMAT(IPOS,KLAUF)
          IF(XI.LT.0.1) DP(KLAUF)=0.0D0
  150   CONTINUE
      ELSE
        IPOS=(JPARAM-24)/2
        DO 151 K1=1,JDIM
         DO 151 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=-HMAT(IPOS,KLAUF)*(VAU+0.5)
          IF(XI.LT.0.1) DP(KLAUF)=0.0D0
  151   CONTINUE
      ENDIF
      GOTO 30
C
C ZEEMAN STRUCTURE
C
C
    6 CONTINUE
      IF(MOD(JPARAM,2).EQ.1) THEN
        IPOS=(JPARAM-31)/2
        DO 160 K1=1,JDIM
         DO 160 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=ZMAT(IPOS,KLAUF)*BX(1)
  160   CONTINUE
      ELSE
        IPOS=(JPARAM-32)/2
        DO 161 K1=1,JDIM
         DO 161 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=-ZMAT(IPOS,KLAUF)*BX(1)*(VAU+0.5)
  161   CONTINUE
      ENDIF
      GOTO 30
    7 CONTINUE
      IF(JPARAM.LE.42) THEN
        DO 170 K1=1,JDIM
         DO 171 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=(VAU+0.5)*RHO(ISO)*P(1)*ATOM(JPARAM-40,ISO)
  171    CONTINUE
  170   CONTINUE
      ELSE
        IPOS1=(JPARAM-43)/2
        IPOS2=MOD(JPARAM,2)
         IF(IPOS2.EQ.0) IPOS2=2
         DO 173 K1=1,JDIM
         DO 174 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=QMAT(IPOS1,KLAUF)*P(IPOS1+4)*ATOM(IPOS2,ISO)
  174    CONTINUE
  173   CONTINUE
      ENDIF
      GOTO 30
    9 CONTINUE
      WRITE(2,*) ' PARAMETER 67....70 NOT DEFINED !'
      GOTO 30
   30 CONTINUE
      RETURN
C     DEBUG INIT
      END
C
C---------------------------------------------------------------------
C
      SUBROUTINE DERIV0(JPARAM)
C
C     LOADS DERIVATIVES OF H WRT P(JPARAM) IN ROW ORDER INTO VECTOR DP
C
C     CHANGED TO PAR(V)=PAR(E)+ALPHA(P)*(V+0.5)+BETA(P)*(V+0.5)**2+...
C     JMB 12-4-95
C
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION DP(1830),BX(15),RHO(7),ATOM(2,7),DDMAT(3,1830),XIA(7)
      DIMENSION QMAT(9,1830),DMAT(6,1830),HMAT(4,1830),ZMAT(7,1830)
      DIMENSION P(80)
      DIMENSION EQMAT(2,1830)
      COMMON/CONS/P
      COMMON/MODE/ IFLD,ISPEC,INTEN
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/DIM/JDIM
      COMMON/ZZZ/DP
      COMMON/QMATS/QMAT
      COMMON/ZMATS/ZMAT
      COMMON/HMATS/HMAT
      COMMON/EQMATS/EQMAT
      COMMON/DMATS/DMAT
      COMMON/DDMATS/DDMAT
      COMMON/FIELD/BX
      COMMON/ISOTO/ATOM,RHO,XIA,IBOC,NISO
      DATA ZERO,HALF,ONE,TWO/0.0D0,0.5D0,1.0D0,2.0D0/

c      DO 300 I1=1,9
c       DO 301 I2=1,JDIM
c        WRITE(9,302)(i1,QMAT(I1,1),I3=1,I2)
c  302   FORMAT('isum ',i3,2x,6(D17.10,3X))
c  301  CONTINUE
c  300 CONTINUE

      VAU05=VAU+HALF
      WURHO=DSQRT(RHO(ISO))
      VAUISO=VAU05*WURHO-HALF

      KMAX=JDIM*(JDIM+1)
      KMAX=KMAX/2
      DO 100 K=1,KMAX
      DP(K)=ZERO
  100 CONTINUE

      IF(JPARAM.LT.13) THEN
        IF(MOD(JPARAM,2).EQ.1) THEN
          BOC=ONE+ATOM(1,ISO)*P(JPARAM+40)+ATOM(2,ISO)*P(JPARAM+41)
        ELSE
          BOC=ONE
        ENDIF
      ENDIF
      IF(JPARAM.GE.13) BOC=ONE

        BOCWE=ONE
        BOCWEXE=ONE
C  B-O CORRECTIONS FOR VIBRATIONAL PARAMETERS NOT PROGRAMMED YET
      IF (IBOC.EQ.1) THEN
        BOCWE=ONE
        BOCWEXE=ONE
      ENDIF

C RUNNING ADDRESS  1 VIBRATIONAL CONSTANT
C                  2 FINE STRUCTURE CONSTANT
C                  3 LAMBDA-DOUBLING CONSTANT
C                  4 LAMBDA-DOUBLING IN DELTA STATES
C                  5 HYPERFINE PARAMETER
C                  6 ZEEMAN G-FACTORS
C                  7 BORN-OPPENHEIMER CORRECTION TERM
C                  8 FINE STRUCTURE EXTENSION
C                  9 DUMMY
C		  10 ELECTRIC QUADRUPOLE TERMS
C Parameters 15 and 16 (gams and alpha_gams now sent to 2 instead
C of 3 to  fix bug    4/8/2000)
      GOTO(1,1,1,1,
     &     2,2,2,2,2,2,2,2,2,2,2,2,
     &     3,3,3,3,
     &     4,4,4,4,
     &     5,5,5,5,5,5,5,5,
     &     6,6,6,6,6,6,6,6,
     &     7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
     &     2,2,2,2,3,3,3,3,3,3,6,6,6,6,
C PARAMETERS 61 TO 66 ARE TEMPORARILY o_D,alpha(o_D),etc
C PARAMETERS 67 TO 70 ARE gl`,alpha-gl`,gre`,...
     &     10,10,10,10,
     &     8,8,8,8,8,8)JPARAM
C
    1 CONTINUE
      GOTO(11,12,13,14),JPARAM
C     DERIV WRT PARAMETER 1  WE
C
   11 DO 101 K=1,JDIM
      KK=K*(K-1)/2+K
      DP(KK)=(VAU05)*WURHO*BOCWE
  101 CONTINUE
      GO TO 30
C
C     DERIV WRT PARAMETER 2  WEXE
   12 DO 102 K=1,JDIM
      KK=K*(K-1)/2+K
      DP(KK)=2*VAU05*WURHO*BOCWE-(VAU05*WURHO)**2*BOCWEXE
  102 CONTINUE
      GO TO 30
C
C     DERIV WRT PARAMETER 3  WEYE
   13 DO 103 K=1,JDIM
      KK=K*(K-1)/2+K
      DP(KK)=(VAU05*WURHO)**3-3.25D0*VAU05*WURHO*BOCWE
  103 CONTINUE
      GO TO 30
C
C     DERIV WRT PARAMETER 4  WEZE
   14 DO 104 K=1,JDIM
      KK=K*(K-1)/2+K
      DP(KK)=(VAU05*WURHO)**4-5.0D0*VAU05*WURHO*BOCWE
  104 CONTINUE
      GO TO 30
C
C ROTATION AND FINE STRUCTURE
C
C
    2 CONTINUE
C SAB 4/8/2000  Next line changed from .gt.14 to .gt.16 to fix bug in 
C fitting of gammas 
      IF(JPARAM.GT.16) GOTO 200
      IF(MOD(JPARAM,2).EQ.1) THEN
        IPOS=(JPARAM-3)/2
        DO 120 K1=1,JDIM
         DO 120 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=QMAT(IPOS,KLAUF)*BOC
          if (jparam.eq.15) write(8,1991) jparam,ipos,
     &      klauf,qmat(ipos,klauf)
 1991     format(3(I3,2x),f20.4)
          IF(IPOS.EQ.1) DP(KLAUF)=DP(KLAUF)*RHO(ISO)
          IF(IPOS.EQ.3) DP(KLAUF)=DP(KLAUF)*RHO(ISO)
          IF(IPOS.EQ.2) DP(KLAUF)=DP(KLAUF)*RHO(ISO)**2
  120   CONTINUE
      ELSE
        IPOS=(JPARAM-4)/2
        DO 121 K1=1,JDIM
         DO 121 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=QMAT(IPOS,KLAUF)*((VAU+0.5)*WURHO-0.5)
          IF(IPOS.EQ.1) DP(KLAUF)=DP(KLAUF)*RHO(ISO)
          IF(IPOS.EQ.3) DP(KLAUF)=DP(KLAUF)*RHO(ISO)
          IF(IPOS.EQ.2) DP(KLAUF)=DP(KLAUF)*RHO(ISO)**2
  121   CONTINUE
      ENDIF
      GOTO 30
  200   IPOS=(JPARAM-56)
      IF(JPARAM.EQ.60)IPOS=5  
         DO 122 K1=1,JDIM
         DO 122 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=QMAT(IPOS,KLAUF)*
     &    ((WURHO*(VAU+0.5))**2-0.25D0)
          IF(IPOS.EQ.1) DP(KLAUF)=DP(KLAUF)*RHO(ISO)
          IF(IPOS.EQ.2) DP(KLAUF)=DP(KLAUF)*RHO(ISO)**2
          IF(IPOS.EQ.3) DP(KLAUF)=DP(KLAUF)*RHO(ISO)
          IF(IPOS.EQ.5) DP(KLAUF)=DP(KLAUF)*WURHO
  122   CONTINUE
      GOTO 30
C
C      FINE STRUCTURE EXTENSION                     
C
    8 CONTINUE
      IF(MOD(JPARAM,2).EQ.1) THEN
        IPOS=(JPARAM-61)/2
        DO 180 K1=1,JDIM
         DO 180 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=QMAT(IPOS,KLAUF)*BOC
          IF(IPOS.EQ.7) DP(KLAUF)=DP(KLAUF)*RHO(ISO)**2
          IF(IPOS.EQ.8) DP(KLAUF)=DP(KLAUF)*RHO(ISO)
          IF(IPOS.EQ.9) DP(KLAUF)=DP(KLAUF)*RHO(ISO)**3
  180   CONTINUE
      ELSE
        IPOS=(JPARAM-62)/2
        DO 181 K1=1,JDIM
         DO 181 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=QMAT(IPOS,KLAUF)*((VAU+0.5)*WURHO-0.5)
          IF(IPOS.EQ.7) DP(KLAUF)=DP(KLAUF)*RHO(ISO)**2
          IF(IPOS.EQ.8) DP(KLAUF)=DP(KLAUF)*RHO(ISO)
          IF(IPOS.EQ.9) DP(KLAUF)=DP(KLAUF)*RHO(ISO)**3
  181   CONTINUE
      ENDIF
      GOTO 30
C
C LAMBDA-DOUBLING FOR PI STATES
C
C
    3 CONTINUE
C  TEMPORARY FIX FOR o_D,ETC (PARAMETER NOS 61 TO 66)
	IFIX = 0
	IF(JPARAM.GT.60) IFIX = 2
      IF(MOD(JPARAM,2).EQ.1) THEN
        IPOS=(JPARAM-13)/2
	IF(JPARAM.GT.60) IPOS = IPOS-20
        DO 130 K1=1,JDIM
         DO 130 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=DMAT(IPOS,KLAUF)*IABS(IPAR)
          DP(KLAUF)=DP(KLAUF)*RHO(ISO)**(IPOS-1-IFIX)
  130   CONTINUE
      ELSE
        IPOS=(JPARAM-14)/2
	IF(JPARAM.GT.60) IPOS = IPOS-20
        DO 131 K1=1,JDIM
         DO 131 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=DMAT(IPOS,KLAUF)*VAUISO*IABS(IPAR)
          DP(KLAUF)=DP(KLAUF)*RHO(ISO)**(IPOS-1-IFIX)
  131   CONTINUE
      ENDIF
      GOTO 30
C
C LAMBDA-DOUBLING IN DELTA-STATES
C
C
    4 CONTINUE
      IF(MOD(JPARAM,2).EQ.1) THEN
        IPOS=(JPARAM-19)/2
        DO 140 K1=1,JDIM
         DO 140 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=DDMAT(IPOS,KLAUF)*IABS(IPAR)
          DP(KLAUF)=DP(KLAUF)*RHO(ISO)**(5-IPOS)
  140   CONTINUE
      ELSE
        IPOS=(JPARAM-20)/2
        DO 141 K1=1,JDIM
         DO 141 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=DDMAT(IPOS,KLAUF)*((VAU+0.5)*WURHO-0.5)
     &               *IABS(IPAR)
          IF(IPOS.EQ.1) DP(KLAUF)=DP(KLAUF)*RHO(ISO)**(5-IPOS)
  141   CONTINUE
      ENDIF
      GOTO 30
C
C HYPERFINE STRUCTURE
C
    5 CONTINUE
      IF(XI.LT.0.1D0) THEN
	DP(KLAUF)=ZERO
	GOTO 30
       ENDIF
      IF(MOD(JPARAM,2).EQ.1) THEN
        IPOS=(JPARAM-23)/2
        DO 150 K1=1,JDIM
         DO 150 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=HMAT(IPOS,KLAUF)
  150   CONTINUE
      ELSE
        IPOS=(JPARAM-24)/2
        DO 151 K1=1,JDIM
         DO 151 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=HMAT(IPOS,KLAUF)*(VAU05-HALF)
  151   CONTINUE
      ENDIF
      GOTO 30
C
C ELECTRIC QUADRUPOLE TERMS
C

C
C    ELECTRIC QUADRUPOLE TERMS 
C
   10 CONTINUE
      IF(XI.LT.0.9D0) THEN
	DP(KLAUF)=ZERO
	GOTO 30
       ENDIF
      IF(MOD(JPARAM,2).EQ.1) THEN
        IPOS=(JPARAM-69)/2
        DO 190 K1=1,JDIM
         DO 190 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=EQMAT(IPOS,KLAUF)
  190   CONTINUE
      ELSE
        IPOS=(JPARAM-70)/2
        DO 191 K1=1,JDIM
         DO 191 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=EQMAT(IPOS,KLAUF)*VAUISO
  191   CONTINUE
      ENDIF
      GOTO 30
C
C ZEEMAN STRUCTURE
C
    6 CONTINUE
      IF(JPARAM.GE.67) GOTO 162
      IF(MOD(JPARAM,2).EQ.1) THEN
        IPOS=(JPARAM-31)/2
        DO 160 K1=1,JDIM
         DO 160 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=ZMAT(IPOS,KLAUF)*BX(1)
  160   CONTINUE
      ELSE
        IPOS=(JPARAM-32)/2
        DO 161 K1=1,JDIM
         DO 161 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=ZMAT(IPOS,KLAUF)*BX(1)*(VAU05-HALF)
  161   CONTINUE
      ENDIF
      GOTO 30
  162 IF(MOD(JPARAM,2).EQ.1) THEN
        IPOS=(JPARAM-67)/2+5
        DO 163 K1=1,JDIM
         DO 163 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=ZMAT(IPOS,KLAUF)*BX(1)
  163   CONTINUE
      ELSE
        IPOS=(JPARAM-68)/2+5
        DO 164 K1=1,JDIM
         DO 164 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=ZMAT(IPOS,KLAUF)*BX(1)*(VAU05-HALF)
 164    CONTINUE
      ENDIF  
      GOTO 30
    7 CONTINUE
      IF(JPARAM.LE.42) THEN
        DO 170 K1=1,JDIM
         DO 171 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=(VAU+0.5)*RHO(ISO)*P(1)*ATOM(JPARAM-40,ISO)
  171    CONTINUE
  170   CONTINUE
      ELSE
        IPOS1=(JPARAM-43)/2
        IPOS2=MOD(JPARAM,2)
         IF(IPOS2.EQ.0) IPOS2=2
        DO 173 K1=1,JDIM
         DO 174 K2=1,K1
          KLAUF=K1*(K1-1)/2+K2
          DP(KLAUF)=QMAT(IPOS1,KLAUF)*(P(IPOS1+4)+0.5*P(IPOS1+5))*
     &              ATOM(IPOS2,ISO)
  174    CONTINUE
  173   CONTINUE
      ENDIF
    9 CONTINUE
      WRITE(2,*) ' PARAMETER 67...70 NOT DEFINED !'
      GOTO 30
   30 CONTINUE
      RETURN
C     DEBUG INIT
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE EDERIV(IEV,DEDB)
C
C     SUBROUTINE TO CALCULATE THE RATE OF ENERGY LEVEL WITH MAGNETIC
C     FIELD
C     N.B.  NOT PROGRAMMED FOR DELTA STATES
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 L(60)
      DIMENSION EIGVEC(60,60),ZMAT(7,1830),HZ(1830)
      COMMON/B/VAU,XL,XS,XI,XN,XJ,XHFS,XM,IPAR,ISO,IDN
      COMMON/LTO/ EIGVEC,L
      COMMON/ZMATS/ZMAT
      COMMON/DIM/JDIM
      COMMON/MOLPZ/GS,GL,GR,GLS,GLP,GRP,GI
      DATA IGS,IGL,IGR,IGLS,IGLP,IGRP,IGI,IGSUM/1,2,3,4,5,6,7,7/
 
      DO 1 IA=1,JDIM
      DO 1 IB=1,IA
      ISYM = IA*(IA-1)/2+IB
      HZ(ISYM) = 0.0D0
      HZ(ISYM) = HZ(ISYM)+GS*ZMAT(IGS,ISYM)
      HZ(ISYM) = HZ(ISYM)+GL*ZMAT(IGL,ISYM)
      HZ(ISYM) = HZ(ISYM)+GR*ZMAT(IGR,ISYM)
      HZ(ISYM) = HZ(ISYM)+GLS*ZMAT(IGLS,ISYM)
      IF (DABS(XL-1.0D0).LT.0.1D0) THEN
        HZ(ISYM)=HZ(ISYM)+GLP*ZMAT(IGLP,ISYM)
	HZ(ISYM)=HZ(ISYM)+GRP*ZMAT(IGRP,ISYM)
      ENDIF
      HZ(ISYM)=HZ(ISYM)+GI*ZMAT(IGI,ISYM)
    1 CONTINUE
      DEDB = FABA(EIGVEC,JDIM,HZ,IEV)
      RETURN
      END
C
C---------------------------------------------------------------------
C
      FUNCTION FABA(A,IP,B,IJ)
C
C     CALCULATES THE IJTH DIAGONAL ELEMENT OF THE MATRIX PRODUCT
C     A(T).B.A  A IS A SQUARE MATRIX  B IS A SQR SYMMETRIC MATRIX
C     THE LOWER HALF OF WHICH IS STORED IN ROW ORDER IN VECTOR B
C
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(60,60),B(1830)
      CJT=0.0
      FABA=0.0
      DO 200 IT=1,IP
      DO 100 IS=1,IP
      K=IS*(IS-1)/2+IT
      IF(IS.LT.IT) K=IT*(IT-1)/2+IS
      ASJ=A(IS,IJ)
      BST=B(K)
      CJT=CJT+ASJ*BST
  100 CONTINUE
      ATJ=A(IT,IJ)
      FABA=FABA+CJT*ATJ
      CJT=0.0
  200 CONTINUE
      RETURN
      END
C
C---------------------------------------------------------------------
C
      SUBROUTINE ORTHOA
C
C     THIS IS AN ALMOST EXACT COPY OF ORTHOA FROM TJS PROF
C
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Z(31,1200),Y(1200),W(1200),CS(31),COF(31),CV(31,31),
     1 VCV(31,31),C(31,1200),D(31,31),DI(31,31),WKS(31)
      COMMON/LSQ1/STD,CHECK,NZ,MZ
      COMMON/LSQ2/Z,Y,W,CS,COF,CV
C
C     LINEAR LSQ ROUTINE USING MATINV PGM
C     INPUT Z MATRIX OF DERIVATIVES Y OBSERVATIONS  W WEIGHTS
C
      REAL*8 DET,WRKDI(31,31)
      INTEGER LWKS1(31),LWKS2(31)
C
      DET=1.0D0
C     MZX IS THE MAXIMUM NUMBER OF VARIABLES
      MZX=31
      LZ=NZ-MZ
      RLZ=DBLE(LZ)
C     WRITE(2,*) RLZ, LZ 
      IF(LZ) 200,11,12
   11 LZ=1
      RLZ=DBLE(LZ)
C     WRITE(2,*) RLZ, LZ 
   12 DO 1 I=1,MZ
      DO 1 J=1,NZ
    1 C(I,J)=Z(I,J)*W(J)
      DO 2 I=1,MZ
      DO 2 J=1,MZ
      D(I,J)=0.0D0
      DO 3 IS=1,NZ
    3 D(I,J)=D(I,J)+C(I,IS)*Z(J,IS)
    2 CV(I,J)=D(I,J)
C                 D    INPUT   (NOT DESTROYED)
C                   DI OUTPUT = D I-NVERTED
C     CALL MATINV(D,DI,MZ,DET,WRKDI,LWKS1,LWKS2)
C     CALL LINV1F(D,MZ,MZX,DI,0,WKS,FAIL)
C          CALL DLINRG(MZ,D,MZX,DI,MZX)
COX      CALL F01AAF(D,MZX,MZ,DI,MZX,WKS,IFAIL)
C	WRITE(2,*) 'D'
C 	DO 1000 ITEST=1,MZ
C       WRITE(2,*) (D(ITEST,JTEST),JTEST=1,MZ)
C 1000	CONTINUE
C 	WRITE(2,*) 'Z'
C 	DO 1001 ITEST=1,MZ
C      WRITE(2,*) (Z(ITEST,JTEST),JTEST=1,NZ)
C 1001	CONTINUE
C
      CALL MINV(D,DI,MZ,MZX,2)
C      WRITE(2,202) IFAIL
C  202 FORMAT(/' SUCCESSFUL MATRIX INVERSION    IFAIL=',I4)
C      IF(IFAIL.GT.0) GOTO 200
C     IF(DET.EQ.0.) GO TO 200
      DO 5 I=1,MZ
      WKS(I)=0.0D0
      DO 5 J=1,NZ
    5 WKS(I)=WKS(I)+C(I,J)*Y(J)
      DO 4 I=1,MZ
      COF(I)=0.0D0
      DO 4 J=1,MZ
    4 COF(I)=COF(I)+DI(I,J)*WKS(J)
      DO 6 J=1,NZ
      C(1,J)=0.0D0
      DO 7 IS=1,MZ
    7 C(1,J)=C(1,J)+Z(IS,J)*COF(IS)
    6 C(1,J)=Y(J)-C(1,J)
      FNUM=0.0
      DO 8 I=1,NZ
      C(2,I)=C(1,I)*W(I)
    8 FNUM=FNUM+C(2,I)*C(1,I)
      STD=FNUM/RLZ
      DO 10 I=1,MZ
      DO 10 J=1,I
      VCV(I,J)=STD*DI(I,J)
   10 VCV(J,I)=VCV(I,J)

      write (2,541)
  541 FORMAT(/41X,'***VARIANCE-COVARIANCE MATRIX***')
      DO 54 I=1,MZ
      WRITE(2,551) (VCV(I,K),K=1,I)
   54 CONTINUE
  551 FORMAT(/' ',10(D10.4,3X))

      STD=DSQRT(STD)
      DO 21 I=1,MZ
      CV(I,I)=1.0D0
      CS(I)=DSQRT(VCV(I,I))
      IF(I.EQ.MZ) GO TO 20
      J1=I+1
      DO 21 J=J1,MZ
      CV(I,J)=VCV(I,J)/DSQRT(VCV(I,I)*VCV(J,J))
   21 CV(J,I)=CV(I,J)
   20 CHECK=1.0
      RETURN
  200 CHECK=-1.0
      WRITE(2,201) IFAIL
  201 FORMAT(/' MATRIX SINGULAR  IFAIL=',I4)
      RETURN
      END
C---------------------------------------------------------------
C234567
      SUBROUTINE MINV(A,Y,N,NP,IPL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z), INTEGER (I-N)
      DIMENSION A(NP,NP),Y(NP,NP),INDX(40)
C Implements Crout's LU decomposition  with partial pivoting and
C scaling, followed by forwards and backwards substitution, to
C inver the matrix A(N,N). A is destroyed. The inverse is Y(N,N).
C See Numerical Recipes pp 35-38.
c      IF(IPL.EQ.1) PRINT*,'FROM SPCFIT'
c      IF(IPL.EQ.2) PRINT*,'FROM ORTHOA'
      DO 12 I=1,N,1
       DO 11 J=1,N,1
        Y(I,J)=0.0D0
 11   CONTINUE
       Y(I,I)=1.0D0
 12   CONTINUE
      CALL LUDCMP(A,N,NP,INDX,D)
      DO 13 J=1,N,1
       CALL LUBKSB(A,N,NP,INDX,Y(1,J))
 13   CONTINUE
      RETURN
      END
 
      SUBROUTINE LUDCMP(A,N,NP,INDX,D)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z), INTEGER (I-N)
      PARAMETER(NMAX=40,TINY=1.0D-20)
      DIMENSION A(NP,NP),INDX(40),VV(40)
      D=1.0D0
      DO 12 I=1,N,1
       AAMAX=0.0D0
       DO 11 J=1,N,1
        IF(DABS(A(I,J)).GT.AAMAX) AAMAX=DABS(A(I,J))
 11    CONTINUE
       IF(AAMAX.EQ.0.0D0)THEN
       WRITE(*,*) '  SINGULAR MATRIX'
       PRINT*,'AAMAX AT FAILURE=',AAMAX
       VV(I)=1.0D0/AAMAX
       ENDIF
 12   CONTINUE
      DO 19 J=1,N,1
       DO 14 I=1,J-1,1
        SUM=A(I,J)
        DO 13 K=1,I-1,1
         SUM=SUM-A(I,K)*A(K,J)
 13     CONTINUE
        A(I,J)=SUM
 14    CONTINUE
       AAMAX=0.0D0
       DO 16 I=J,N,1
        SUM=A(I,J)
        DO 15 K=1,J-1,1
         SUM=SUM-A(I,K)*A(K,J)
 15     CONTINUE
        A(I,J)=SUM
        DUM=VV(I)*DABS(SUM)
        IF(DUM.GE.AAMAX)THEN
         IMAX=I
         AAMAX=DUM
        ENDIF
 16    CONTINUE
       IF(J.NE.IMAX)THEN
        DO 17 K=1,N,1
         DUM=A(IMAX,K)
         A(IMAX,K)=A(J,K)
         A(J,K)=DUM
 17     CONTINUE
        D=-1.0D0*D
        VV(IMAX)=VV(J)
       ENDIF
       INDX(J)=IMAX
       IF(A(J,J).EQ.0.0D0) A(J,J)=TINY
       IF(J.NE.N)THEN
        DUM=1.0D0/A(J,J)
        DO 18 I=J+1,N,1
         A(I,J)=A(I,J)*DUM
 18     CONTINUE
       ENDIF
 19   CONTINUE
      RETURN
      END
 
      SUBROUTINE LUBKSB(A,N,NP,INDX,B)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z), INTEGER (I-N)
C
      DIMENSION A(NP,NP),INDX(NP),B(NP)
      II=0
      DO 12 I=1,N,1
       LL=INDX(I)
       SUM=B(LL)
       B(LL)=B(I)
       IF(II.NE.0)THEN
        DO 11 J=II,I-1,1
         SUM=SUM-A(I,J)*B(J)
11      CONTINUE
       ELSEIF(SUM.NE.0.0D0)THEN
        II=I
       ENDIF
       B(I)=SUM
 12   CONTINUE
      DO 14 I=N,1,-1
       SUM=B(I)
       IF(I.LT.N)THEN
        DO 13 J=I+1,N,1
         SUM=SUM-A(I,J)*B(J)
 13     CONTINUE
       ENDIF
       B(I)=SUM/A(I,I)
 14   CONTINUE
      RETURN
      END
 
c****************************************************************
C SAB 3/8 2000
C New sixj subroutine. Taken from program "bound" by J.Hutson.
C Calculates sixj symbols explicitly with no limit in rank. 


      FUNCTION SIXJ(xJ1x,xJ2x,xJ3x,xJ4x,xJ5x,xJ6x)
C
C     CALCULATES 6-J SYMBOL:   _(J1 J2 J3 )_
C                               (J4 J5 J6 )
C     INTERFACE TO J6J ROUTINE.
C     MODIFIED BY S. GREEN 20 AUG 93; PASS DIMENSION OF XJ6J FOR CHECKING
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER(MXDIM=200)
      DIMENSION XJ6J(MXDIM)
      
c      write(6,*) 'Js',xj1x,xj2x,xj5x,xj4x,xj3x,xj6x
      IVAL=MXDIM
      CALL J6J(         DBLE(xJ2x),DBLE(xJ3x),
     1         DBLE(xJ4x),DBLE(xJ5x),DBLE(xJ6x),
     3         IVAL,XJ1MIN,XJ6J)
      IND=1+xJ1x-INT(XJ1MIN+0.1D0)
c      write(6,*) xj1min,ind,ival
      SIXJ=0.D0
      IF(IND.GE.1 .AND. IND.LE.IVAL) SIXJ=XJ6J(IND)
      RETURN
      END



      SUBROUTINE J6J(J2,J3,L1,L2,L3,IVAL,J1MIN,D6J)

      IMPLICIT DOUBLE PRECISION (A-H,J-Z)
      DIMENSION D6J(2)
      DATA ZERO/0.D0/,TENTH/0.1D0/,HALF/0.5D0/,ONE/1.D0/,TWO/2.D0/,
     $ CONST/1.0D-12/

      E(J1S)=SQRT((J1S-MJ23S)*(J23P1S-J1S)*(J1S-ML23S)*(L23P1S-J1S))
      F(J1,JJP1)=(TWO*J1+ONE)*(JJP1*(FACT-JJP1-TWO*LLP1)+FACT2)
C
C  THIS ROUTINE CALCULATES THE 6-J COEFFICIENTS FOR ALL PERMISSIBLE
C  VALUES OF J1 FOR FIXED VALUES OF J2, J3, L1, L2, AND L3 USING THE
C  RECURSIVE ALGORITHM OF K. SCHULTEN AND R. G. GORDON, J. MATH. PHYS.
C  VOL. 16, P. 1961, (1975).
C  PROGRAMMED BY D. E. FITZ, 10/22/79
C  MODIFIED BY S. GREEN 20 AUG 93 TO TEST DIMENSION ON D6J
C
      MXDIM=IVAL
      JJP2=J2*(J2+ONE)
      JJP3=J3*(J3+ONE)
      LLP1=L1*(L1+ONE)
      LLP2=L2*(L2+ONE)
      LLP3=L3*(L3+ONE)
      MJ23S=(J2-J3)**2
      ML23S=(L2-L3)**2
      J23P1S=(J2+J3+ONE)**2
      L23P1S=(L2+L3+ONE)**2
      FACT2=(LLP2-LLP3)*(JJP2-JJP3)
      FACT=JJP2+JJP3+LLP2+LLP3
      J1MIN=MAX(ABS(J2-J3),ABS(L2-L3))
      J1MAX=MIN(J2+J3,L2+L3)
      IVAL=INT(J1MAX-J1MIN+ONE+TENTH)
      IF (IVAL.GT.MXDIM) THEN
        WRITE(6,*) 'J6J: ARRAY D6J TOO SMALL. NEEDS '
     1   ,IVAL,' BUT ONLY ',MXDIM,' SUPPLIED'
        STOP
      ENDIF
C
C  TEST FOR OTHER TRIANGULAR INEQUALITES.
C
      IL1=INT(TWO*L1+TENTH)
      IL2=INT(TWO*L2+TENTH)
      IL3=INT(TWO*L3+TENTH)
      IJ2=INT(TWO*J2+TENTH)
      IJ3=INT(TWO*J3+TENTH)
      IF((IJ2.LE.IL1+IL3.AND.IJ2.GE.IABS(IL1-IL3)).AND.
     $ (IJ3.LE.IL1+IL2.AND.IJ3.GE.IABS(IL1-IL2))) GO TO 11
      DO 12 I=1,IVAL
   12 D6J(I)=ZERO
      RETURN
C
   11 INMID=(IVAL+3)/2
      SGNV=J2+J3+L2+L3
      SGN=ONE
      ISIGN=INT(SGNV+TENTH)
      IF(MOD(ISIGN,2).NE.0) SGN=-ONE
      D6J(1)=HALF
C
C  UPWARD RECURSION.
C
      IF(IVAL.EQ.1) GO TO 40
      JJP1=J1MIN*(J1MIN+ONE)
      F1=F(J1MIN,JJP1)
      J1=J1MIN+ONE
      J1S=J1*J1
      E2=E(J1S)
      IF(J1MIN.LT.TENTH) GO TO 15
      D6J(2)=-F1*D6J(1)/(E2*J1MIN)
      GO TO 16
   15 D6J(2)=-HALF*(LLP2+JJP2-LLP1)*D6J(1)/SQRT(JJP2*LLP2)
   16 SCALE=D6J(2)
      IF(IVAL.EQ.2) GO TO 40
      DO 21 IJ2=3,INMID
      JJP1=J1*(J1+ONE)
      F1=F(J1,JJP1)
      J1=J1+ONE
      E1=E2
      J1S=J1*J1
      E2=E(J1S)
   21 D6J(IJ2)=-(F1*D6J(IJ2-1)+J1*E1*D6J(IJ2-2))/(E2*(J1-ONE))
      SCALE=D6J(INMID)
      IEXC=5
      IF(ABS(SCALE).GT.CONST) GO TO 18
      INMID=INMID-1
      SCALE=D6J(INMID)
      IEXC=3
      GO TO 30
   18 IF(IVAL.EQ.3) GO TO 40
C
C  DOWNWARD RECURSION.
C
   30 D6J(IVAL)=HALF
      J1=J1MAX
      J1S=J1*J1
      JJP1=J1*(J1+ONE)
      F1=F(J1,JJP1)
      E1=E(J1S)
      D6J(IVAL-1)=-F1*D6J(IVAL)/(E1*(J1+ONE))
      IEND=IVAL-INMID
      IF(IVAL.LE.IEXC) GO TO 31
      DO 32 IJ2=2,IEND
      J1=J1-ONE
      E2=E1
      J1S=J1*J1
      JJP1=J1*(J1+ONE)
      E1=E(J1S)
      F1=F(J1,JJP1)
   32 D6J(IVAL-IJ2)=-(J1*E2*D6J(IVAL-IJ2+2)+F1*D6J(IVAL-IJ2+1))/
     $ (E1*(J1+ONE))
C
C  MATCH UPWARD AND DOWNWARD RECURSIVE RESULTS BY SCALING.
C
   31 SCALE=SCALE/D6J(INMID)
      DO 33 IJ2=INMID,IVAL
   33 D6J(IJ2)=SCALE*D6J(IJ2)
C
C  NORMALIZE RESULTS AND SET PHASE.
C
   40 SUM=ZERO
      DO 41 IJ2=1,IVAL
      J1=J1MIN+DBLE(IJ2-1)
   41 SUM=SUM+(TWO*J1+ONE)*D6J(IJ2)**2
      RNORM=ONE/SQRT(SUM*(TWO*L1+ONE))
      IF((SGN*D6J(IVAL)).LT.ZERO) RNORM=-RNORM
      DO 42 IJ2=1,IVAL
   42 D6J(IJ2)=D6J(IJ2)*RNORM
c         write(6,*) 'j1min = ',j1min
      RETURN
      END

c****************************************************************
C---------------------------------------------------------------
C SUBSECTION 15
C*F45V1P0*
      DOUBLE PRECISION FUNCTION THREEJ(BB,CC,AA,YY,ZZ,XX)
      IMPLICIT REAL*8 (A-H,O-Z)
      DATA ZERO,HALF,ONE,TWO /0.0D0,0.5D0,1.0D0,2.0D0/
C
C     CALCULATES WIGNER 3-J SYMBOL USING EXPLICIT EXPRESSIONS
C     GIVEN BY EDMONDS.
C     C IS THE ORDER, Z ITS COMPONENT
 
C      EXTERNAL NINT
C      WRITE(2,1100) BB, CC, AA, YY, ZZ, XX
C1100  FORMAT(' IN THREEJ BB=(',F10.5,'),CC=(',F10.5,'),AA=
C     1(',F10.5,'),YY=(',F10.5,'),ZZ=(',F10.5,'),
C     2XX=(',F10.5,') ')
      A=AA
      B=BB
      C=CC
      X=XX
      Y=YY
      Z=ZZ
C      WRITE(2,1000) C
C1000  FORMAT(' IN THREEJ C= ',F20.10)
      IF(C.GT.2.0D0) GO TO 18
      K=2*C
      IF(MOD(K,2).EQ.1) GO TO 17
      MZERO=NINT(X+Y+Z)
      IF(MZERO.NE.0) GO TO 1
      IF(A.LT.DABS(X).OR.B.LT.DABS(Y).OR.C.LT.DABS(Z)) GO TO 1
      JDEL=NINT(A-B)
      IDEL=IABS(JDEL)
      Q=DMAX1(A,B,C)
      S=A+B+C-Q
      IF(Q.GT.S) GO TO 1
      PHASE=ONE
      SIGN=ONE
      FAC=ONE
      IF(IDEL.EQ.JDEL) GO TO 2
      D=A
      W=X
      A=B
      X=Y
      B=D
      Y=W
      INDEX=IABS(NINT(A+B+C))
      IF(MOD(INDEX,2).EQ.1) PHASE=-ONE
    2 IF(Z.GE.ZERO) GO TO3
      X=-X
      Y=-Y
      Z=-Z
      INDEX=IABS(NINT(A+B+C))
      IF(MOD(INDEX,2).EQ.1) SIGN=-ONE
    3 INDEX=IABS(NINT(A-X))
      IF(MOD(INDEX,2).EQ.1) FAC=-ONE
      PHASE=PHASE*FAC*SIGN
C     RANK ZERO 3-J SYMBOL
      IF(K.EQ.0) GO TO 21
      I=5*Z+2*C+IDEL-1
      GO TO(4,5,6,7,8,9,10,11,12,13,1,1,14,15,16),I
      WRITE(2,1112) IDEL
1112  FORMAT(' IN THREEJ IDEL= ',I20)
      WRITE(2,1113) C
1113  FORMAT(' IN THREEJ C = ',F20.10)
      WRITE(2,1114) Z
1114  FORMAT(' IN THREEJ Z = ',F20.10)
C      WRITE(2,1111) I
C1111  FORMAT( ' IN THREEJ I BEFORE ERROR= ',I20)
      WRITE(2,1110)
1110  FORMAT( ' ERROR IN THREEJ ')
C      CALL GOTOER
    4 THREEJ=PHASE*X/SQRT(A*(A+ONE)*(TWO*A+ONE))
      RETURN
    5 THREEJ=PHASE*SQRT((B+X+ONE)*(B-X+ONE)/((B+ONE)*
     1(TWO*B+ONE)*(TWO*B+3.0D0)))
      RETURN
    6 THREEJ=PHASE*(3.0D0*X*X-A*(A+ONE))/SQRT(A*(A+ONE)*(TWO*A+ONE)
     1*(TWO*A-ONE)*(TWO*A+3.0D0))
      RETURN
    7 THREEJ=PHASE*X*SQRT(3.0D0*(B+X+ONE)*(B-X+ONE)/(B*(B+ONE)
     1*(B+TWO)*(TWO*B+ONE)*(TWO*B+3.0D0)))
      RETURN
    8 THREEJ=PHASE*SQRT(3.0D0*(B+X+TWO)*(B+X+ONE)*(B-X+TWO)*(B-X+ONE)/
     1(TWO*(B+ONE)*(B+TWO)*(TWO*B+ONE)*(TWO*B+3.0D0)*(TWO*B+5.0D0)))
      RETURN
    9 THREEJ=PHASE*SQRT((A-X)*(A+X+ONE)/(TWO*A*(A+ONE)*(TWO*A+ONE)))
      RETURN
   10 THREEJ=PHASE*SQRT((B-X)*(B-X+ONE)/(TWO*(B+ONE)*(TWO*B+ONE)
     1*(TWO*B+3.0D0)))
      RETURN
   11 THREEJ=PHASE*(ONE+TWO*X)*SQRT(3.0D0*(A-X)*(A+X+ONE)/(A*(A+ONE)
     1*(TWO*A+ONE)*(TWO*A-ONE)*(TWO*A+3.0D0)*TWO))
      RETURN
   12 THREEJ=PHASE*(B+X+X+TWO)*SQRT((B-X)*(B-X+ONE)/(B*(B+ONE)*(B+TWO)
     1*TWO*(TWO*B+ONE)*(TWO*B+3.0D0)))
      RETURN
   13 THREEJ=PHASE*SQRT((B-X)*(B-X+ONE)*(B-X+TWO)*(B+X+TWO)/((B+ONE)*
     1(B+TWO)*(TWO*B+ONE)*(TWO*B+3.0D0)*(TWO*B+5.0D0)))
      RETURN
   14 THREEJ=PHASE*SQRT(3.0D0*(A-X-ONE)*(A-X)*(A+X+ONE)*(A+X+TWO)/(A*
     1(A+ONE)*(TWO*A+ONE)*(TWO*A+3.0D0)*(TWO*A-ONE)*TWO))
      RETURN
   15 THREEJ=PHASE*SQRT((B-X)*(B-X-ONE)*(B-X+ONE)*(B+X+TWO)/
     1(TWO*B*(B+ONE)*(B+TWO)*(TWO*B+ONE)*(TWO*B+3.0D0)))
      RETURN
   16 THREEJ=PHASE*SQRT((B-X)*(B-X-ONE)*(B-X+ONE)*(B-X+TWO)/((TWO*B+ONE)
     1*(TWO*B+3.0D0)*(TWO*B+5.0D0)*(B+ONE)*(B+TWO)*4.0D0))
      RETURN
C FEHLS:
   17  CONTINUE
           IF(IIIII.LT.3) THEN
      WRITE(2,20) BB,CC,AA,YY,ZZ,XX
   20 FORMAT('  THREEJ(',6F5.1,') HAS A HALF-INTEGER RANK, WHICH IS PHYS
     1ICALLY MEANINGLESS')
      THREEJ=ZERO
              IIIII=IIIII+1
              ENDIF
      RETURN
   18 WRITE(2,19) BB,CC,AA,YY,ZZ,XX,CC
   19 FORMAT(' CANNOT DO THREEJ(',6F5.1,') AS RANK ',F4.1,' IS TOO'
     1,' HIGH.',/,' PROGRAM IT YOURSELF IF YOU REALLY WANT IT &')
      THREEJ=ZERO
      RETURN
C     SPECIAL CASE WHEN RANK IS ZERO
   21 THREEJ=FAC/SQRT(TWO*A+ONE)
      RETURN
    1 THREEJ=ZERO
      RETURN
      END
C--------------------------------------------------------------------
